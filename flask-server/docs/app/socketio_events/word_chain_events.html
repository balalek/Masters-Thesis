<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>app.socketio_events.word_chain_events API documentation</title>
<meta name="description" content="Socket.IO event handlers for Word Chain gameplay …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.socketio_events.word_chain_events</code></h1>
</header>
<section id="section-intro">
<p>Socket.IO event handlers for Word Chain gameplay.</p>
<p>This module provides real-time event handling for the Word Chain question type:</p>
<ul>
<li>Word submission and validation against Czech dictionary</li>
<li>Player turn management and team rotation</li>
<li>Diacritics handling for letter matching</li>
<li>Time tracking and player elimination</li>
<li>Points calculation and scoring</li>
<li>Game state synchronization across clients</li>
</ul>
<p>The Word Chain gameplay involves players taking turns to submit words that
start with the last letter of the previous word, with special handling for
team-based play and invalid letter sequences.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="app.socketio_events.word_chain_events.award_points_for_word"><code class="name flex">
<span>def <span class="ident">award_points_for_word</span></span>(<span>player_name, word)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def award_points_for_word(player_name, word):
    &#34;&#34;&#34;
    Award points for a valid word submission.
    
    Points are awarded based on word length in free-for-all mode.
    In team mode, points are handled by the bomb explosion mechanism.
    
    Args:
        player_name: The player who submitted the word
        word: The submitted word
    &#34;&#34;&#34;
    global game_points

    if not game_state.is_team_mode:        
        total_points = len(word) * POINTS_FOR_LETTER
        
        # Initialize player in game_points if not exists
        if player_name not in game_points:
            game_points[player_name] = 0
        
        # Add points to game-specific tracker
        game_points[player_name] += total_points
        
        if player_name in game_state.players:
            game_state.players[player_name][&#39;score&#39;] += total_points</code></pre>
</details>
<div class="desc"><p>Award points for a valid word submission.</p>
<p>Points are awarded based on word length in free-for-all mode.
In team mode, points are handled by the bomb explosion mechanism.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player_name</code></strong></dt>
<dd>The player who submitted the word</dd>
<dt><strong><code>word</code></strong></dt>
<dd>The submitted word</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.check_game_end"><code class="name flex">
<span>def <span class="ident">check_game_end</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_game_end():
    &#34;&#34;&#34;
    Check if the game should end.
    
    In free-for-all mode, ends when only 0-1 players remain.
    Team mode game end is triggered by the bomb explosion event.
    &#34;&#34;&#34;
    if not game_state.is_team_mode:
        # Free-for-all: game ends when 0 or 1 players remain
        active_players = [p for p in game_state.word_chain_state[&#39;player_order&#39;] 
                        if p not in game_state.word_chain_state[&#39;eliminated_players&#39;]]
        
        if len(active_players) &lt;= 1:
            # Game is over
            handle_word_chain_game_end()
    
    # Team mode game end is triggered by the bomb exploding, handled by frontend</code></pre>
</details>
<div class="desc"><p>Check if the game should end.</p>
<p>In free-for-all mode, ends when only 0-1 players remain.
Team mode game end is triggered by the bomb explosion event.</p></div>
</dd>
<dt id="app.socketio_events.word_chain_events.check_word_exists"><code class="name flex">
<span>def <span class="ident">check_word_exists</span></span>(<span>word)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_word_exists(word):
    &#34;&#34;&#34;
    Check if a word exists in the dictionary.
    
    Uses the loaded dictionary to validate word existence.
    Falls back to accepting all words if dictionary check fails.
    
    Args:
        word: Word to validate
        
    Returns:
        bool: True if word exists or error occurs, False if word definitely doesn&#39;t exist
    &#34;&#34;&#34;
    try:
        if dictionary_words:
            return word_exists(word, dictionary_words)
        else:
            # If dictionary is empty, accept all words
            return True
        
    except Exception as e:
        print(f&#34;Error checking word existence: {str(e)}&#34;)
        return True</code></pre>
</details>
<div class="desc"><p>Check if a word exists in the dictionary.</p>
<p>Uses the loaded dictionary to validate word existence.
Falls back to accepting all words if dictionary check fails.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>word</code></strong></dt>
<dd>Word to validate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if word exists or error occurs, False if word definitely doesn't exist</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.eliminate_player"><code class="name flex">
<span>def <span class="ident">eliminate_player</span></span>(<span>player_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eliminate_player(player_name):
    &#34;&#34;&#34;
    Eliminate a player who ran out of time.
    
    Adds the player to the eliminated set and advances the game if needed.
    Checks if the game should end after elimination.
    
    Args:
        player_name: The player to eliminate
    &#34;&#34;&#34;
    if player_name not in game_state.word_chain_state[&#39;eliminated_players&#39;]:
        game_state.word_chain_state[&#39;eliminated_players&#39;].add(player_name)
        
        # If this was the current player, move to next player
        if game_state.word_chain_state[&#39;current_player&#39;] == player_name:
            next_player = get_next_player(player_name)
            game_state.word_chain_state[&#39;current_player&#39;] = next_player
        
        # Broadcast update
        send_word_chain_update()
        
        # Check if game is over (only one or no players left)
        check_game_end()</code></pre>
</details>
<div class="desc"><p>Eliminate a player who ran out of time.</p>
<p>Adds the player to the eliminated set and advances the game if needed.
Checks if the game should end after elimination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player_name</code></strong></dt>
<dd>The player to eliminate</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.get_last_valid_letter"><code class="name flex">
<span>def <span class="ident">get_last_valid_letter</span></span>(<span>word)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_valid_letter(word):
    &#34;&#34;&#34;
    Get the last valid letter of a word for the next player to use.
    
    Handles special cases where the last letter can&#39;t be used to start words.
    In such cases, picks a random valid letter instead.
    
    Args:
        word: The word from which to get the last letter
        
    Returns:
        str: Valid letter for the next player to use
    &#34;&#34;&#34;
    # Remove diacritics and convert to lowercase
    normalized_word = remove_diacritics(word).lower()
    
    # Get the last letter
    last_letter = normalized_word[-1]
    
    # If last letter is invalid, pick a random valid letter
    if last_letter in INVALID_ENDING_LETTERS:
        valid_letters = list(set(string.ascii_lowercase) - set(INVALID_ENDING_LETTERS))
        return random.choice(valid_letters)
        
    return last_letter</code></pre>
</details>
<div class="desc"><p>Get the last valid letter of a word for the next player to use.</p>
<p>Handles special cases where the last letter can't be used to start words.
In such cases, picks a random valid letter instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>word</code></strong></dt>
<dd>The word from which to get the last letter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Valid letter for the next player to use</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.get_next_player"><code class="name flex">
<span>def <span class="ident">get_next_player</span></span>(<span>current_player)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_player(current_player):
    &#34;&#34;&#34;
    Get the next player in the game rotation.
    
    Handles team mode and free-for-all mode differently:

    - In team mode: Alternates between teams and tracks player indexes
    - In free-for-all: Uses player order and skips eliminated players
    
    Args:
        current_player: The current active player
        
    Returns:
        str: Name of the next player, None if no active players remain
    &#34;&#34;&#34;
    if game_state.is_team_mode:
        # Get current teams and indexes
        red_players = game_state.red_team.copy()
        blue_players = game_state.blue_team.copy()
        team_indexes = game_state.word_chain_state[&#39;team_indexes&#39;]
        
        # Get current player&#39;s team
        current_team = get_player_team(current_player)
        
        # Determine next team (always alternate)
        next_team = &#39;blue&#39; if current_team == &#39;red&#39; else &#39;red&#39;
        
        # Calculate the immediate next player first
        next_team_players = blue_players if next_team == &#39;blue&#39; else red_players
        next_idx = (team_indexes[next_team] + 1) % len(next_team_players)
        immediate_next_player = next_team_players[next_idx]
        
        # Calculate future players for display (get the two players after the immediate next)
        next_players = []
        temp_team = next_team
        temp_indexes = team_indexes.copy()
        temp_indexes[next_team] = next_idx  # Start from after the immediate next player
        
        # Get two players after the immediate next
        for i in range(2):
            temp_team = &#39;blue&#39; if temp_team == &#39;red&#39; else &#39;red&#39;
            players = blue_players if temp_team == &#39;blue&#39; else red_players
            temp_idx = (temp_indexes[temp_team] + 1) % len(players)
            next_players.append(players[temp_idx])
            temp_indexes[temp_team] = temp_idx

        game_state.word_chain_state[&#39;next_players&#39;] = next_players
        
        # Update the game state
        team_indexes[next_team] = next_idx
        
        # Update previous and next players arrays
        game_state.word_chain_state[&#39;previous_players&#39;] = [current_player]
        if len(game_state.word_chain_state[&#39;word_chain&#39;]) &gt; 1:
            last_word = game_state.word_chain_state[&#39;word_chain&#39;][-2]
            game_state.word_chain_state[&#39;previous_players&#39;].append(last_word[&#39;player&#39;])
        
        return immediate_next_player

    else:
        # Free-for-all mode: use player order
        player_order = game_state.word_chain_state[&#39;player_order&#39;]
        
        # Find the index of the current player in the ORIGINAL order
        # (even if they&#39;ve just been eliminated)
        try:
            original_index = player_order.index(current_player)
            
            # Start looking from the next position in the original order
            next_index = (original_index + 1) % len(player_order)
            
            # Now find the next active player starting from this position
            eliminated_players = game_state.word_chain_state[&#39;eliminated_players&#39;]
            
            # We may need to loop through all players to find the next active one
            for _ in range(len(player_order)):
                next_candidate = player_order[next_index]
                if next_candidate not in eliminated_players:
                    return next_candidate
                
                # Move to the next player in the order
                next_index = (next_index + 1) % len(player_order)
                
            # If we&#39;ve gone through all players and found none active
            return None
            
        except ValueError:
            # Current player not found in player_order (shouldn&#39;t happen)
            # Fall back to first non-eliminated player
            active_players = [p for p in player_order if p not in game_state.word_chain_state[&#39;eliminated_players&#39;]]
            return active_players[0] if active_players else None</code></pre>
</details>
<div class="desc"><p>Get the next player in the game rotation.</p>
<p>Handles team mode and free-for-all mode differently:</p>
<ul>
<li>In team mode: Alternates between teams and tracks player indexes</li>
<li>In free-for-all: Uses player order and skips eliminated players</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>current_player</code></strong></dt>
<dd>The current active player</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Name of the next player, None if no active players remain</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.get_player_team"><code class="name flex">
<span>def <span class="ident">get_player_team</span></span>(<span>player_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_player_team(player_name):
    &#34;&#34;&#34;
    Get the team of a player.
    
    Args:
        player_name: The name of the player
        
    Returns:
        str: &#39;blue&#39; or &#39;red&#39; if player is in a team, None otherwise
    &#34;&#34;&#34;
    if player_name in game_state.blue_team:
        return &#39;blue&#39;
    elif player_name in game_state.red_team:
        return &#39;red&#39;
    
    return None</code></pre>
</details>
<div class="desc"><p>Get the team of a player.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player_name</code></strong></dt>
<dd>The name of the player</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>'blue' or 'red' if player is in a team, None otherwise</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.handle_word_chain_game_end"><code class="name flex">
<span>def <span class="ident">handle_word_chain_game_end</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_word_chain_game_end():
    &#34;&#34;&#34;
    Handle the end of a word chain game round.
    
    Calculates final scores and awards bonuses:

    - In free-for-all mode: Last surviving player gets a bonus
    - Prepares result statistics for display
    - Broadcasts results to all clients
    - Resets game-specific points for next round
    &#34;&#34;&#34;
    global game_points
    scores = get_scores_data()
    
    # For free-for-all, the last player gets a bonus
    if not game_state.is_team_mode:
        active_players = [p for p in game_state.word_chain_state[&#39;player_order&#39;] 
                        if p not in game_state.word_chain_state[&#39;eliminated_players&#39;]]
        
        if len(active_players) == 1:
            # Award survival bonus to the last player
            last_player = active_players[0]
            survival_bonus = POINTS_FOR_WORD_CHAIN
            game_state.players[last_player][&#39;score&#39;] += survival_bonus
            
            # Also add to game-specific points
            if last_player not in game_points:
                game_points[last_player] = 0
            game_points[last_player] += survival_bonus
            
            # Update scores
            scores = get_scores_data()
    
    # Get stats for the result screen
    word_chain_stats = {
        &#39;word_chain&#39;: game_state.word_chain_state[&#39;word_chain&#39;],
        &#39;last_player&#39;: game_state.word_chain_state[&#39;current_player&#39;],
        &#39;eliminated_players&#39;: list(game_state.word_chain_state[&#39;eliminated_players&#39;]),
        &#39;game_points&#39;: game_points
    }
    
    # Send results to everyone
    emit_all_answers_received(
        scores=scores,
        correct_answer=&#34;&#34;, # No correct answer for word chain
        additional_data=word_chain_stats
    )

    game_points = {}</code></pre>
</details>
<div class="desc"><p>Handle the end of a word chain game round.</p>
<p>Calculates final scores and awards bonuses:</p>
<ul>
<li>In free-for-all mode: Last surviving player gets a bonus</li>
<li>Prepares result statistics for display</li>
<li>Broadcasts results to all clients</li>
<li>Resets game-specific points for next round</li>
</ul></div>
</dd>
<dt id="app.socketio_events.word_chain_events.handle_word_chain_time_up"><code class="name flex">
<span>def <span class="ident">handle_word_chain_time_up</span></span>(<span>scores)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_word_chain_time_up(scores):
    &#34;&#34;&#34;
    Handle when time is up for word chain questions.
    
    Processes the end of game timer (as opposed to player timer).
    In team mode, acts as if the bomb exploded for the active team.
    
    Args:
        scores: Current game scores for inclusion in results
        
    Emits:
        - Event via emit_all_answers_received with game results
    &#34;&#34;&#34;
    if game_state.is_team_mode:
        # In team mode, time up means the bomb exploded for the active team
        active_team = get_player_team(game_state.word_chain_state[&#39;current_player&#39;])
        
        # Award points to the winning team
        winning_team = &#39;red&#39; if active_team == &#39;blue&#39; else &#39;blue&#39;
        game_state.team_scores[winning_team] += POINTS_FOR_SURVIVING_BOMB  # Bonus for winning team
        
        # Update scores
        scores = get_scores_data()
        
        # Send results to everyone
        emit_all_answers_received(
            scores=scores,
            correct_answer=&#34;&#34;,
            additional_data={
                &#39;word_chain&#39;: game_state.word_chain_state[&#39;word_chain&#39;],
                &#39;exploded_team&#39;: active_team,
                &#39;winning_team&#39;: winning_team,
                &#39;exploded_player&#39;: game_state.word_chain_state[&#39;current_player&#39;],
                &#39;game_points&#39;: POINTS_FOR_SURVIVING_BOMB
            }
        )</code></pre>
</details>
<div class="desc"><p>Handle when time is up for word chain questions.</p>
<p>Processes the end of game timer (as opposed to player timer).
In team mode, acts as if the bomb exploded for the active team.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scores</code></strong></dt>
<dd>Current game scores for inclusion in results</dd>
</dl>
<h2 id="emits">Emits</h2>
<ul>
<li>Event via emit_all_answers_received with game results</li>
</ul></div>
</dd>
<dt id="app.socketio_events.word_chain_events.handle_word_chain_timeout"><code class="name flex">
<span>def <span class="ident">handle_word_chain_timeout</span></span>(<span>data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@socketio.on(&#39;word_chain_timeout&#39;)
def handle_word_chain_timeout(data):
    &#34;&#34;&#34;
    Handle when a player&#39;s timer runs out in free-for-all mode.
    
    Called when a player&#39;s time expires completely.
    Initiates player elimination from the game.
    
    Args:
        data (dict):
        
            - player: The player whose timer ran out
            
    Emits:
        - &#39;word_chain_update&#39;: Updated game state after player elimination
    &#34;&#34;&#34;
    player = data.get(&#39;player&#39;)
    if player:
        eliminate_player(player)</code></pre>
</details>
<div class="desc"><p>Handle when a player's timer runs out in free-for-all mode.</p>
<p>Called when a player's time expires completely.
Initiates player elimination from the game.</p>
<h2 id="args">Args</h2>
<p>data (dict):</p>
<pre><code>- player: The player whose timer ran out
</code></pre>
<h2 id="emits">Emits</h2>
<ul>
<li>'word_chain_update': Updated game state after player elimination</li>
</ul></div>
</dd>
<dt id="app.socketio_events.word_chain_events.initialize_player_order"><code class="name flex">
<span>def <span class="ident">initialize_player_order</span></span>(<span>round_length)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_player_order(round_length):
    &#34;&#34;&#34;
    Initialize the order of players in free-for-all mode.
    
    Randomizes player order and initializes timers for each player.
    
    Args:
        round_length: Time in seconds for each player&#39;s turn
    &#34;&#34;&#34;
    player_order = list(game_state.players.keys())
    random.shuffle(player_order)  # Randomize player order
    game_state.word_chain_state[&#39;player_order&#39;] = player_order
    
    # Initialize player timers
    for player in player_order:
        game_state.word_chain_state[&#39;player_timers&#39;][player] = round_length * 1000  # Convert to milliseconds</code></pre>
</details>
<div class="desc"><p>Initialize the order of players in free-for-all mode.</p>
<p>Randomizes player order and initializes timers for each player.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>round_length</code></strong></dt>
<dd>Time in seconds for each player's turn</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.initialize_team_order"><code class="name flex">
<span>def <span class="ident">initialize_team_order</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_team_order():
    &#34;&#34;&#34;
    Initialize the order of players in team mode.
    
    Sets up initial team order with randomized starting team.
    Creates team indexes to track rotation position within each team.
    &#34;&#34;&#34;
    red_players = game_state.red_team.copy()
    blue_players = game_state.blue_team.copy()
    
    # Randomize the starting team
    start_with_red = random.choice([True, False])
    
    # Create minimal team order with just the first person
    if start_with_red and red_players:
        # Initialize with first red player
        game_state.word_chain_state[&#39;team_order&#39;] = [(red_players[0], &#39;red&#39;)]
        # Store team indexes to track where we are in each team&#39;s rotation
        game_state.word_chain_state[&#39;team_indexes&#39;] = {&#39;red&#39;: 0, &#39;blue&#39;: -1}
    elif blue_players:
        # Initialize with first blue player
        game_state.word_chain_state[&#39;team_order&#39;] = [(blue_players[0], &#39;blue&#39;)]
        # Store team indexes to track where we are in each team&#39;s rotation
        game_state.word_chain_state[&#39;team_indexes&#39;] = {&#39;red&#39;: -1, &#39;blue&#39;: 0}</code></pre>
</details>
<div class="desc"><p>Initialize the order of players in team mode.</p>
<p>Sets up initial team order with randomized starting team.
Creates team indexes to track rotation position within each team.</p></div>
</dd>
<dt id="app.socketio_events.word_chain_events.load_dictionary"><code class="name flex">
<span>def <span class="ident">load_dictionary</span></span>(<span>dic_file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_dictionary(dic_file_path):
    &#34;&#34;&#34;
    Load words from dictionary file into a set for quick lookup.
    
    Loads a Czech language dictionary for validating words during gameplay.
    Handles encoding issues and filters out non-word content from the dictionary file.
    
    Args:
        dic_file_path: Path to the dictionary file
        
    Returns:
        set: Set of words from the dictionary, or empty set if loading failed
    &#34;&#34;&#34;
    words = set()
    
    if not os.path.exists(dic_file_path):
        print(f&#34;Dictionary file not found: {dic_file_path}&#34;)
        return words
        
    try:
        with open(dic_file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            # Process the file
            for line in f:
                # Strip and add words (ignoring any flags after &#39;/&#39;)
                word = line.strip().split(&#39;/&#39;)[0].lower()
                if word:
                    words.add(word)
                    
        return words
    
    except Exception as e:
        print(f&#34;Error loading dictionary: {str(e)}&#34;)
        return words</code></pre>
</details>
<div class="desc"><p>Load words from dictionary file into a set for quick lookup.</p>
<p>Loads a Czech language dictionary for validating words during gameplay.
Handles encoding issues and filters out non-word content from the dictionary file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dic_file_path</code></strong></dt>
<dd>Path to the dictionary file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>Set of words from the dictionary, or empty set if loading failed</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.remove_diacritics"><code class="name flex">
<span>def <span class="ident">remove_diacritics</span></span>(<span>text)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_diacritics(text):
    &#34;&#34;&#34;
    Remove diacritics from Czech text.
    
    Handles Czech-specific characters by replacing them with their base form.
    
    Args:
        text: Text containing Czech diacritics
        
    Returns:
        str: Text with diacritics removed
    &#34;&#34;&#34;
    replacements = {
        &#39;á&#39;: &#39;a&#39;,
        &#39;é&#39;: &#39;e&#39;,
        &#39;ě&#39;: &#39;e&#39;,
        &#39;í&#39;: &#39;i&#39;,
        &#39;ó&#39;: &#39;o&#39;,
        &#39;ý&#39;: &#39;y&#39;,
        &#39;ň&#39;: &#39;n&#39;,
        &#39;ť&#39;: &#39;t&#39;,
        &#39;ď&#39;: &#39;d&#39;,
        &#39;ů&#39;: &#39;ú&#39;
    }
    
    result = text
    for char, replacement in replacements.items():
        result = result.replace(char, replacement)
        result = result.replace(char.upper(), replacement.upper())
    
    return result</code></pre>
</details>
<div class="desc"><p>Remove diacritics from Czech text.</p>
<p>Handles Czech-specific characters by replacing them with their base form.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>Text containing Czech diacritics</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Text with diacritics removed</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.word_chain_events.send_word_chain_update"><code class="name flex">
<span>def <span class="ident">send_word_chain_update</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_word_chain_update():
    &#34;&#34;&#34;
    Send current word chain state to all clients.
    
    Broadcasts the complete game state including:

    - Word chain history
    - Current player and letter
    - Player progression (previous and next players)
    - Eliminated players and timer information
    - Current scores and game-specific points
    
    Emits:
        - &#39;word_chain_update&#39;: Complete word chain state to all clients
    &#34;&#34;&#34;
    scores = {
        &#39;individual&#39;: {}
    }
    
    for player_name in game_state.players:
        scores[&#39;individual&#39;][player_name] = {
            &#39;score&#39;: game_state.players[player_name][&#39;score&#39;],
            &#39;color&#39;: game_state.players[player_name][&#39;color&#39;]
        }
    
    socketio.emit(&#39;word_chain_update&#39;, {
        &#39;word_chain&#39;: game_state.word_chain_state[&#39;word_chain&#39;],
        &#39;current_letter&#39;: game_state.word_chain_state[&#39;current_letter&#39;],
        &#39;current_player&#39;: game_state.word_chain_state[&#39;current_player&#39;],
        &#39;previous_players&#39;: game_state.word_chain_state[&#39;previous_players&#39;],
        &#39;next_players&#39;: game_state.word_chain_state[&#39;next_players&#39;],
        &#39;eliminated_players&#39;: list(game_state.word_chain_state[&#39;eliminated_players&#39;]),
        &#39;player_timers&#39;: game_state.word_chain_state[&#39;player_timers&#39;],
        &#39;scores&#39;: scores,
        &#39;game_points&#39;: game_points
    })</code></pre>
</details>
<div class="desc"><p>Send current word chain state to all clients.</p>
<p>Broadcasts the complete game state including:</p>
<ul>
<li>Word chain history</li>
<li>Current player and letter</li>
<li>Player progression (previous and next players)</li>
<li>Eliminated players and timer information</li>
<li>Current scores and game-specific points</li>
</ul>
<h2 id="emits">Emits</h2>
<ul>
<li>'word_chain_update': Complete word chain state to all clients</li>
</ul></div>
</dd>
<dt id="app.socketio_events.word_chain_events.start_word_chain"><code class="name flex">
<span>def <span class="ident">start_word_chain</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@socketio.on(&#39;start_word_chain&#39;)
def start_word_chain():
    &#34;&#34;&#34;
    Initialize and start a new word chain game.
    
    Sets up the initial game state for word chain:

    - Resets game-specific points
    - Sets the first word (or random letter if no word provided)
    - Establishes the current letter for the first player
    - Prepares player order and team setup
    
    This function is called both when the game first starts and 
    when advancing to a new word chain question.
    &#34;&#34;&#34;
    global game_points
    game_points = {}  # Reset game-specific points

    current_question = game_state.questions[game_state.current_question]
    
    # Set first word and letter
    first_word = current_question.get(&#39;first_word&#39;, &#39;&#39;)
    if first_word:
        # Start with the provided first word
        game_state.word_chain_state[&#39;word_chain&#39;].append({
            &#39;word&#39;: first_word,
            &#39;player&#39;: &#39;system&#39;,
            &#39;team&#39;: None
        })
        game_state.word_chain_state[&#39;used_words&#39;].add(first_word)
        game_state.word_chain_state[&#39;current_letter&#39;] = get_last_valid_letter(first_word).upper()
    else:
        # If no first word provided, start with a random letter
        valid_letters = list(set(string.ascii_uppercase) - set([l.upper() for l in INVALID_ENDING_LETTERS]))
        game_state.word_chain_state[&#39;current_letter&#39;] = random.choice(valid_letters)</code></pre>
</details>
<div class="desc"><p>Initialize and start a new word chain game.</p>
<p>Sets up the initial game state for word chain:</p>
<ul>
<li>Resets game-specific points</li>
<li>Sets the first word (or random letter if no word provided)</li>
<li>Establishes the current letter for the first player</li>
<li>Prepares player order and team setup</li>
</ul>
<p>This function is called both when the game first starts and
when advancing to a new word chain question.</p></div>
</dd>
<dt id="app.socketio_events.word_chain_events.submit_word_chain_word"><code class="name flex">
<span>def <span class="ident">submit_word_chain_word</span></span>(<span>data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@socketio.on(&#39;submit_word_chain_word&#39;)
def submit_word_chain_word(data):
    &#34;&#34;&#34;
    Handle player submission of a word in the word chain game.
    
    Validates the submitted word against multiple rules:

    - Player must be the current active player
    - Word must not be previously used
    - Word must start with the current required letter
    - Word must be in the dictionary
    - Word must be at least 3 letters long
    
    If valid, awards points, advances to the next player, and broadcasts updates.
    
    Args:
        data (dict): 

            - player_name: Name of the player submitting the word
            - word: The word being submitted
    
    Emits:
        - &#39;word_chain_feedback&#39;: Success or error feedback to the player
    &#34;&#34;&#34;
    global game_points
    player_name = data[&#39;player_name&#39;]
    word = data[&#39;word&#39;].strip().lower()
    
    # Skip processing if current player is not the one submitting
    if game_state.word_chain_state[&#39;current_player&#39;] != player_name:
        emit(&#39;word_chain_feedback&#39;, {
            &#39;success&#39;: False,
            &#39;message&#39;: &#39;Nejsi na řadě!&#39;
        }, room=player_name)
        return
    
    # Check if player has been eliminated (should not happen normally)
    if player_name in game_state.word_chain_state[&#39;eliminated_players&#39;]:
        emit(&#39;word_chain_feedback&#39;, {
            &#39;success&#39;: False,
            &#39;message&#39;: &#39;Byl jsi vyřazen z hry!&#39;
        }, room=player_name)
        return
    
    current_letter = game_state.word_chain_state[&#39;current_letter&#39;]
    
    # Check if word have at least 3 letters
    if len(word) &lt; 3:
        emit(&#39;word_chain_feedback&#39;, {
            &#39;success&#39;: False,
            &#39;message&#39;: &#39;Slovo musí mít alespoň 3 písmena!&#39;
        }, room=player_name)
        return
    
    # Check if word starts with the required letter
    if not word.startswith(current_letter.lower()) and not word.startswith(remove_diacritics(current_letter).lower()):
        emit(&#39;word_chain_feedback&#39;, {
            &#39;success&#39;: False,
            &#39;message&#39;: f&#39;Slovo musí začínat na písmeno {current_letter}!&#39;
        }, room=player_name)
        return
        
    # Check if word has already been used
    if word in game_state.word_chain_state[&#39;used_words&#39;]:
        emit(&#39;word_chain_feedback&#39;, {
            &#39;success&#39;: False,
            &#39;message&#39;: &#39;Toto slovo již bylo použito!&#39;
        }, room=player_name)
        return

    # Check if word exists in dictionary
    if not check_word_exists(word):
        emit(&#39;word_chain_feedback&#39;, {
            &#39;success&#39;: False,
            &#39;message&#39;: &#39;Toto slovo neexistuje ve slovníku!&#39;
        }, room=player_name)
        return
    
    # Word is valid - add to chain and update game state
    game_state.word_chain_state[&#39;used_words&#39;].add(word)
    game_state.word_chain_state[&#39;word_chain&#39;].append({
        &#39;word&#39;: word,
        &#39;player&#39;: player_name,
        &#39;team&#39;: get_player_team(player_name)
    })
    
    # Award points for valid word
    award_points_for_word(player_name, word)
    
    # Get next letter from the last letter of the word
    last_letter = get_last_valid_letter(word)
    game_state.word_chain_state[&#39;current_letter&#39;] = last_letter.upper()
    
    # Get next player and update game state
    next_player = get_next_player(player_name)
    game_state.word_chain_state[&#39;current_player&#39;] = next_player
        
    # Broadcast updated word chain to all clients
    send_word_chain_update()
    
    # Emit success feedback to the player
    emit(&#39;word_chain_feedback&#39;, {
        &#39;success&#39;: True,
        &#39;message&#39;: &#39;Slovo přijato!&#39;
    }, room=player_name)</code></pre>
</details>
<div class="desc"><p>Handle player submission of a word in the word chain game.</p>
<p>Validates the submitted word against multiple rules:</p>
<ul>
<li>Player must be the current active player</li>
<li>Word must not be previously used</li>
<li>Word must start with the current required letter</li>
<li>Word must be in the dictionary</li>
<li>Word must be at least 3 letters long</li>
</ul>
<p>If valid, awards points, advances to the next player, and broadcasts updates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<ul>
<li>player_name: Name of the player submitting the word</li>
<li>word: The word being submitted</li>
</ul>
</dd>
</dl>
<h2 id="emits">Emits</h2>
<ul>
<li>'word_chain_feedback': Success or error feedback to the player</li>
</ul></div>
</dd>
<dt id="app.socketio_events.word_chain_events.word_exists"><code class="name flex">
<span>def <span class="ident">word_exists</span></span>(<span>word, words_set)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def word_exists(word, words_set):
    &#34;&#34;&#34;
    Check if a word exists in the dictionary.
    
    Simple lookup in the pre-loaded dictionary set for fast word validation.
    
    Args:
        word: Word to check (case insensitive)
        words_set: Set of words to check against
        
    Returns:
        bool: True if word exists in the dictionary
    &#34;&#34;&#34;
    return word.lower() in words_set</code></pre>
</details>
<div class="desc"><p>Check if a word exists in the dictionary.</p>
<p>Simple lookup in the pre-loaded dictionary set for fast word validation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>word</code></strong></dt>
<dd>Word to check (case insensitive)</dd>
<dt><strong><code>words_set</code></strong></dt>
<dd>Set of words to check against</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if word exists in the dictionary</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app.socketio_events" href="index.html">app.socketio_events</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="app.socketio_events.word_chain_events.award_points_for_word" href="#app.socketio_events.word_chain_events.award_points_for_word">award_points_for_word</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.check_game_end" href="#app.socketio_events.word_chain_events.check_game_end">check_game_end</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.check_word_exists" href="#app.socketio_events.word_chain_events.check_word_exists">check_word_exists</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.eliminate_player" href="#app.socketio_events.word_chain_events.eliminate_player">eliminate_player</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.get_last_valid_letter" href="#app.socketio_events.word_chain_events.get_last_valid_letter">get_last_valid_letter</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.get_next_player" href="#app.socketio_events.word_chain_events.get_next_player">get_next_player</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.get_player_team" href="#app.socketio_events.word_chain_events.get_player_team">get_player_team</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.handle_word_chain_game_end" href="#app.socketio_events.word_chain_events.handle_word_chain_game_end">handle_word_chain_game_end</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.handle_word_chain_time_up" href="#app.socketio_events.word_chain_events.handle_word_chain_time_up">handle_word_chain_time_up</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.handle_word_chain_timeout" href="#app.socketio_events.word_chain_events.handle_word_chain_timeout">handle_word_chain_timeout</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.initialize_player_order" href="#app.socketio_events.word_chain_events.initialize_player_order">initialize_player_order</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.initialize_team_order" href="#app.socketio_events.word_chain_events.initialize_team_order">initialize_team_order</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.load_dictionary" href="#app.socketio_events.word_chain_events.load_dictionary">load_dictionary</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.remove_diacritics" href="#app.socketio_events.word_chain_events.remove_diacritics">remove_diacritics</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.send_word_chain_update" href="#app.socketio_events.word_chain_events.send_word_chain_update">send_word_chain_update</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.start_word_chain" href="#app.socketio_events.word_chain_events.start_word_chain">start_word_chain</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.submit_word_chain_word" href="#app.socketio_events.word_chain_events.submit_word_chain_word">submit_word_chain_word</a></code></li>
<li><code><a title="app.socketio_events.word_chain_events.word_exists" href="#app.socketio_events.word_chain_events.word_exists">word_exists</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
