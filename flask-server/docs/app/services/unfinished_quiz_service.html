<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>app.services.unfinished_quiz_service API documentation</title>
<meta name="description" content="Unfinished quiz management service â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.services.unfinished_quiz_service</code></h1>
</header>
<section id="section-intro">
<p>Unfinished quiz management service.</p>
<p>This module provides functionality for handling quizzes that are being created or edited (the drafts):</p>
<ul>
<li>Saving quiz drafts to local storage during creation/editing drafts</li>
<li>Retrieving saved drafts for resuming work</li>
<li>Managing autosave functionality</li>
<li>Validating and cleaning up media files for incomplete quizzes</li>
<li>Deleting drafts and associated resources</li>
</ul>
<p>The service uses TinyDB for local storage to persist quiz data between sessions.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="app.services.unfinished_quiz_service.UnfinishedQuizService"><code class="flex name class">
<span>class <span class="ident">UnfinishedQuizService</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnfinishedQuizService:
    &#34;&#34;&#34;
    Service for managing unfinished (draft) quizzes in local storage.
    
    Provides methods for saving, retrieving, and deleting quiz drafts,
    with support for autosave functionality and media validation.
    All operations are tied to the current device ID to ensure privacy.
    &#34;&#34;&#34;
    
    @staticmethod
    def save_unfinished_quiz(quiz_data: Dict[str, Any], is_editing: bool = False, 
                           quiz_id: Optional[str] = None, autosave_id: Optional[str] = None) -&gt; Tuple[bool, str]:
        &#34;&#34;&#34;
        Save or update an unfinished quiz in the local database.
        
        Handles both new quiz drafts and updates to existing drafts.
        Generates a unique identifier for new drafts or uses the provided autosave_id.
        
        Args:
            quiz_data: Dictionary containing the quiz data to save
            is_editing: Whether this is an edit of an existing quiz
            quiz_id: ID of the original quiz being edited (if applicable)
            autosave_id: Existing autosave identifier for updates
            
        Returns:
            tuple: (success_boolean, autosave_identifier)
                   
                   (False, None) if saving fails
        &#34;&#34;&#34;
        # Don&#39;t save if we&#39;re editing an existing quiz, since it&#39;s not implemented
        if is_editing:
            return False, None
            
        if not local_db:
            print(&#34;Local database not available&#34;)
            return False, None
        
        try:
            device_id = get_device_id()
            
            # Determine the identifier for this autosave
            identifier = None
            
            # If autosave_id was provided, use that - this means we&#39;re updating an existing autosave
            if autosave_id:
                identifier = autosave_id
            else:
                # Always create a unique ID for a new quiz
                identifier = f&#34;new_{int(datetime.now().timestamp())}_{hash(str(quiz_data))}&#34;
            
            # Basic validation
            if not quiz_data or not quiz_data.get(&#39;questions&#39;) or not isinstance(quiz_data.get(&#39;questions&#39;), list):
                print(&#34;Invalid quiz data - missing questions array&#34;)
                return False, None
                
            # Prepare quiz data
            save_data = {
                &#34;identifier&#34;: identifier,
                &#34;name&#34;: quiz_data.get(&#39;name&#39;, &#39;Unnamed Quiz&#39;),
                &#34;questions&#34;: json.dumps(quiz_data.get(&#39;questions&#39;)),  # Serialize questions to string
                &#34;quiz_type&#34;: quiz_data.get(&#39;quiz_type&#39;, &#39;ABCD&#39;),
                &#34;is_editing&#34;: is_editing,
                &#34;original_quiz_id&#34;: quiz_id,
                &#34;device_id&#34;: device_id,
                &#34;last_updated&#34;: datetime.now().isoformat(),
                &#34;question_count&#34;: len(quiz_data.get(&#39;questions&#39;, [])),
                &#34;creation_time&#34;: datetime.now().isoformat() # Track when it was first created
            }
            
            # Check if this quiz already exists by identifier
            Quiz = Query()
            existing = local_db[&#39;unfinished_quizzes&#39;].search(Quiz.identifier == identifier)
            
            if existing:
                # Update existing record
                local_db[&#39;unfinished_quizzes&#39;].update(save_data, Quiz.identifier == identifier)
            else:
                # Create new record
                local_db[&#39;unfinished_quizzes&#39;].insert(save_data)
            
            return True, identifier
        
        except Exception as e:
            print(f&#34;Error saving unfinished quiz: {e}&#34;)
            return False, None
    
    @staticmethod
    def get_unfinished_quizzes() -&gt; List[Dict[str, Any]]:
        &#34;&#34;&#34;
        Get all unfinished quizzes for the current device.
        
        Retrieves all saved drafts associated with the current device ID,
        sorted by last update time (newest first).
        
        Returns:
            list: List of quiz draft metadata dictionaries with:

                 - identifier: Unique ID for the draft
                 - name: Quiz title
                 - is_editing: Whether this is an edit of an existing quiz
                 - original_quiz_id: ID of the original quiz being edited
                 - last_updated: Timestamp of last save
                 - question_count: Number of questions in the draft
        &#34;&#34;&#34;
        if not local_db:
            return []
        
        try:
            device_id = get_device_id()
            Quiz = Query()
            
            quizzes = local_db[&#39;unfinished_quizzes&#39;].search(Quiz.device_id == device_id)
            
            # Format quizzes for display
            formatted_quizzes = []
            for q in quizzes:
                formatted_quizzes.append({
                    &#34;identifier&#34;: q.get(&#34;identifier&#34;),
                    &#34;name&#34;: q.get(&#34;name&#34;),
                    &#34;is_editing&#34;: q.get(&#34;is_editing&#34;),
                    &#34;original_quiz_id&#34;: q.get(&#34;original_quiz_id&#34;),
                    &#34;last_updated&#34;: q.get(&#34;last_updated&#34;),
                    &#34;question_count&#34;: q.get(&#34;question_count&#34;, 0)
                })
            
            # Sort by last updated, newest first
            formatted_quizzes.sort(key=lambda x: x.get(&#34;last_updated&#34;, &#34;&#34;), reverse=True)
            
            return formatted_quizzes
        
        except Exception as e:
            print(f&#34;Error retrieving unfinished quizzes: {e}&#34;)
            return []
    
    @staticmethod
    def get_unfinished_quiz(identifier: str) -&gt; Optional[Dict[str, Any]]:
        &#34;&#34;&#34;
        Get a specific unfinished quiz by identifier.
        
        Retrieves a complete quiz draft including all questions.
        Performs validation on media URLs and question references to ensure
        all referenced resources still exist.
        
        Args:
            identifier: The unique identifier of the quiz draft
            
        Returns:
            dict: Complete quiz draft with validated questions, or None if not found. 
                  The returned quiz includes:

                  - identifier: Unique ID
                  - name: Quiz title
                  - questions: List of question objects
                  - quiz_type: Type of quiz
                  - is_editing: Whether this is an edit of an existing quiz
                  - original_quiz_id: ID of the original quiz being edited
                  - last_updated: Timestamp of last save
        &#34;&#34;&#34;
        if not local_db:
            return None
        
        try:
            device_id = get_device_id()
            Quiz = Query()
            
            results = local_db[&#39;unfinished_quizzes&#39;].search(
                (Quiz.identifier == identifier) &amp; 
                (Quiz.device_id == device_id)
            )
            
            if not results:
                return None
                
            quiz_data = results[0]
            
            # Parse questions from JSON
            try:
                questions = json.loads(quiz_data.get(&#34;questions&#34;, &#34;[]&#34;))
                
                # Validate media files still exist in Cloudinary
                questions_with_valid_data = []
                for question in questions:
                    # Check if question has media that needs validation
                    if question.get(&#39;mediaUrl&#39;):
                        # Verify the file exists in Cloudinary
                        if CloudinaryService.check_file_exists(question[&#39;mediaUrl&#39;]):
                            # File exists, include question as-is
                            pass
                        else:
                            # File doesn&#39;t exist, mark media as missing
                            print(f&#34;Media file not found: {question[&#39;mediaUrl&#39;]}&#34;)
                            question[&#39;mediaUrl&#39;] = None
                            question[&#39;mediaType&#39;] = None
                            question[&#39;showImageGradually&#39;] = False
                            question[&#39;mediaFileNotFound&#39;] = True
                    
                    # Check if copy_of reference still exists in MongoDB
                    if question.get(&#39;copy_of&#39;):
                        try:
                            # Validate that the original question still exists
                            original_exists = db.questions.find_one({&#34;_id&#34;: ObjectId(question[&#39;copy_of&#39;])})
                            if not original_exists:
                                # Original question doesn&#39;t exist anymore, remove the reference
                                print(f&#34;Original question not found for copy_of: {question[&#39;copy_of&#39;]}&#34;)
                                question[&#39;copy_of&#39;] = None

                        except Exception as e:
                            # If there&#39;s any error (invalid ObjectId, etc.), remove the reference
                            print(f&#34;Error checking copy_of reference: {e}&#34;)
                            question[&#39;copy_of&#39;] = None
                    
                    questions_with_valid_data.append(question)
                
                # Replace original questions with validated ones
                questions = questions_with_valid_data
                
            except Exception as e:
                print(f&#34;Error parsing/validating questions: {e}&#34;)
                questions = []
            
            return {
                &#34;identifier&#34;: quiz_data.get(&#34;identifier&#34;),
                &#34;name&#34;: quiz_data.get(&#34;name&#34;),
                &#34;questions&#34;: questions,
                &#34;quiz_type&#34;: quiz_data.get(&#34;quiz_type&#34;),
                &#34;is_editing&#34;: quiz_data.get(&#34;is_editing&#34;),
                &#34;original_quiz_id&#34;: quiz_data.get(&#34;original_quiz_id&#34;),
                &#34;last_updated&#34;: quiz_data.get(&#34;last_updated&#34;),
                &#34;media_validation_performed&#34;: True  # Flag to indicate media was checked
            }
        
        except Exception as e:
            print(f&#34;Error retrieving unfinished quiz: {e}&#34;)
            return None
    
    @staticmethod
    def delete_unfinished_quiz(identifier: str, keep_files: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        Delete an unfinished quiz and optionally its associated media files.
        
        Removes the quiz draft from local storage and optionally cleans up
        any media files that were uploaded specifically for this draft.
        
        Args:
            identifier: The unique identifier of the quiz draft
            keep_files: If True, don&#39;t delete media files (used when quiz was completed)
            
        Returns:
            bool: True if deletion was successful, False otherwise
        &#34;&#34;&#34;
        if not local_db:
            return False
        
        try:
            device_id = get_device_id()
            Quiz = Query()
            
            # First, fetch the quiz to get its questions for media cleanup
            quiz_data = UnfinishedQuizService.get_unfinished_quiz(identifier)
            if quiz_data and quiz_data.get(&#39;questions&#39;) and not keep_files:
                # Only delete files if keep_files is False
                # Check if this is an edit of an existing quiz
                is_editing = quiz_data.get(&#39;is_editing&#39;, False)
                original_quiz_id = quiz_data.get(&#39;original_quiz_id&#39;)
                
                # Collect media URLs that need to be deleted
                media_urls_to_delete = set()
                
                # Get all questions with media
                questions_with_media = [q for q in quiz_data[&#39;questions&#39;] if q.get(&#39;mediaUrl&#39;)]
                
                if is_editing and original_quiz_id:
                    # This is an edit of an existing quiz
                    # Get the original quiz to compare media URLs
                    try:
                        # Use MongoDB to get the original quiz
                        original_quiz = db.quizzes.find_one({&#34;_id&#34;: original_quiz_id})
                        if original_quiz:
                            original_question_ids = {str(q_ref[&#39;questionId&#39;]) for q_ref in original_quiz.get(&#39;questions&#39;, [])}
                            
                            # Get all original questions&#39; media URLs
                            original_media_urls = set()
                            if original_question_ids:
                                original_questions = db.questions.find({&#34;_id&#34;: {&#34;$in&#34;: original_question_ids}})
                                original_media_urls = {q.get(&#39;media_url&#39;) for q in original_questions if q.get(&#39;media_url&#39;)}
                            
                            # Only delete media URLs that are not in the original quiz
                            for question in questions_with_media:
                                if question.get(&#39;mediaUrl&#39;) and question.get(&#39;mediaUrl&#39;) not in original_media_urls:
                                    # This is a newly added media file
                                    media_urls_to_delete.add(question.get(&#39;mediaUrl&#39;))

                    except Exception as e:
                        print(f&#34;Error getting original quiz: {e}&#34;)
                        # If we can&#39;t get original quiz, assume all media is new
                        media_urls_to_delete = {q.get(&#39;mediaUrl&#39;) for q in questions_with_media}
                else:
                    # This is a new quiz, delete all media
                    media_urls_to_delete = {q.get(&#39;mediaUrl&#39;) for q in questions_with_media}
                
                # Delete all collected media URLs
                for url in media_urls_to_delete:
                    if url:
                        try:
                            CloudinaryService.delete_file(url)

                        except Exception as e:
                            print(f&#34;Error deleting media file {url}: {e}&#34;)
            
            # Now delete the quiz from local DB
            local_db[&#39;unfinished_quizzes&#39;].remove(
                (Quiz.identifier == identifier) &amp; 
                (Quiz.device_id == device_id)
            )
            
            return True
        
        except Exception as e:
            print(f&#34;Error deleting unfinished quiz: {e}&#34;)
            return False</code></pre>
</details>
<div class="desc"><p>Service for managing unfinished (draft) quizzes in local storage.</p>
<p>Provides methods for saving, retrieving, and deleting quiz drafts,
with support for autosave functionality and media validation.
All operations are tied to the current device ID to ensure privacy.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="app.services.unfinished_quiz_service.UnfinishedQuizService.delete_unfinished_quiz"><code class="name flex">
<span>def <span class="ident">delete_unfinished_quiz</span></span>(<span>identifier:Â str, keep_files:Â boolÂ =Â False) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delete_unfinished_quiz(identifier: str, keep_files: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    Delete an unfinished quiz and optionally its associated media files.
    
    Removes the quiz draft from local storage and optionally cleans up
    any media files that were uploaded specifically for this draft.
    
    Args:
        identifier: The unique identifier of the quiz draft
        keep_files: If True, don&#39;t delete media files (used when quiz was completed)
        
    Returns:
        bool: True if deletion was successful, False otherwise
    &#34;&#34;&#34;
    if not local_db:
        return False
    
    try:
        device_id = get_device_id()
        Quiz = Query()
        
        # First, fetch the quiz to get its questions for media cleanup
        quiz_data = UnfinishedQuizService.get_unfinished_quiz(identifier)
        if quiz_data and quiz_data.get(&#39;questions&#39;) and not keep_files:
            # Only delete files if keep_files is False
            # Check if this is an edit of an existing quiz
            is_editing = quiz_data.get(&#39;is_editing&#39;, False)
            original_quiz_id = quiz_data.get(&#39;original_quiz_id&#39;)
            
            # Collect media URLs that need to be deleted
            media_urls_to_delete = set()
            
            # Get all questions with media
            questions_with_media = [q for q in quiz_data[&#39;questions&#39;] if q.get(&#39;mediaUrl&#39;)]
            
            if is_editing and original_quiz_id:
                # This is an edit of an existing quiz
                # Get the original quiz to compare media URLs
                try:
                    # Use MongoDB to get the original quiz
                    original_quiz = db.quizzes.find_one({&#34;_id&#34;: original_quiz_id})
                    if original_quiz:
                        original_question_ids = {str(q_ref[&#39;questionId&#39;]) for q_ref in original_quiz.get(&#39;questions&#39;, [])}
                        
                        # Get all original questions&#39; media URLs
                        original_media_urls = set()
                        if original_question_ids:
                            original_questions = db.questions.find({&#34;_id&#34;: {&#34;$in&#34;: original_question_ids}})
                            original_media_urls = {q.get(&#39;media_url&#39;) for q in original_questions if q.get(&#39;media_url&#39;)}
                        
                        # Only delete media URLs that are not in the original quiz
                        for question in questions_with_media:
                            if question.get(&#39;mediaUrl&#39;) and question.get(&#39;mediaUrl&#39;) not in original_media_urls:
                                # This is a newly added media file
                                media_urls_to_delete.add(question.get(&#39;mediaUrl&#39;))

                except Exception as e:
                    print(f&#34;Error getting original quiz: {e}&#34;)
                    # If we can&#39;t get original quiz, assume all media is new
                    media_urls_to_delete = {q.get(&#39;mediaUrl&#39;) for q in questions_with_media}
            else:
                # This is a new quiz, delete all media
                media_urls_to_delete = {q.get(&#39;mediaUrl&#39;) for q in questions_with_media}
            
            # Delete all collected media URLs
            for url in media_urls_to_delete:
                if url:
                    try:
                        CloudinaryService.delete_file(url)

                    except Exception as e:
                        print(f&#34;Error deleting media file {url}: {e}&#34;)
        
        # Now delete the quiz from local DB
        local_db[&#39;unfinished_quizzes&#39;].remove(
            (Quiz.identifier == identifier) &amp; 
            (Quiz.device_id == device_id)
        )
        
        return True
    
    except Exception as e:
        print(f&#34;Error deleting unfinished quiz: {e}&#34;)
        return False</code></pre>
</details>
<div class="desc"><p>Delete an unfinished quiz and optionally its associated media files.</p>
<p>Removes the quiz draft from local storage and optionally cleans up
any media files that were uploaded specifically for this draft.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifier</code></strong></dt>
<dd>The unique identifier of the quiz draft</dd>
<dt><strong><code>keep_files</code></strong></dt>
<dd>If True, don't delete media files (used when quiz was completed)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if deletion was successful, False otherwise</dd>
</dl></div>
</dd>
<dt id="app.services.unfinished_quiz_service.UnfinishedQuizService.get_unfinished_quiz"><code class="name flex">
<span>def <span class="ident">get_unfinished_quiz</span></span>(<span>identifier:Â str) â€‘>Â Dict[str,Â Any]Â |Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_unfinished_quiz(identifier: str) -&gt; Optional[Dict[str, Any]]:
    &#34;&#34;&#34;
    Get a specific unfinished quiz by identifier.
    
    Retrieves a complete quiz draft including all questions.
    Performs validation on media URLs and question references to ensure
    all referenced resources still exist.
    
    Args:
        identifier: The unique identifier of the quiz draft
        
    Returns:
        dict: Complete quiz draft with validated questions, or None if not found. 
              The returned quiz includes:

              - identifier: Unique ID
              - name: Quiz title
              - questions: List of question objects
              - quiz_type: Type of quiz
              - is_editing: Whether this is an edit of an existing quiz
              - original_quiz_id: ID of the original quiz being edited
              - last_updated: Timestamp of last save
    &#34;&#34;&#34;
    if not local_db:
        return None
    
    try:
        device_id = get_device_id()
        Quiz = Query()
        
        results = local_db[&#39;unfinished_quizzes&#39;].search(
            (Quiz.identifier == identifier) &amp; 
            (Quiz.device_id == device_id)
        )
        
        if not results:
            return None
            
        quiz_data = results[0]
        
        # Parse questions from JSON
        try:
            questions = json.loads(quiz_data.get(&#34;questions&#34;, &#34;[]&#34;))
            
            # Validate media files still exist in Cloudinary
            questions_with_valid_data = []
            for question in questions:
                # Check if question has media that needs validation
                if question.get(&#39;mediaUrl&#39;):
                    # Verify the file exists in Cloudinary
                    if CloudinaryService.check_file_exists(question[&#39;mediaUrl&#39;]):
                        # File exists, include question as-is
                        pass
                    else:
                        # File doesn&#39;t exist, mark media as missing
                        print(f&#34;Media file not found: {question[&#39;mediaUrl&#39;]}&#34;)
                        question[&#39;mediaUrl&#39;] = None
                        question[&#39;mediaType&#39;] = None
                        question[&#39;showImageGradually&#39;] = False
                        question[&#39;mediaFileNotFound&#39;] = True
                
                # Check if copy_of reference still exists in MongoDB
                if question.get(&#39;copy_of&#39;):
                    try:
                        # Validate that the original question still exists
                        original_exists = db.questions.find_one({&#34;_id&#34;: ObjectId(question[&#39;copy_of&#39;])})
                        if not original_exists:
                            # Original question doesn&#39;t exist anymore, remove the reference
                            print(f&#34;Original question not found for copy_of: {question[&#39;copy_of&#39;]}&#34;)
                            question[&#39;copy_of&#39;] = None

                    except Exception as e:
                        # If there&#39;s any error (invalid ObjectId, etc.), remove the reference
                        print(f&#34;Error checking copy_of reference: {e}&#34;)
                        question[&#39;copy_of&#39;] = None
                
                questions_with_valid_data.append(question)
            
            # Replace original questions with validated ones
            questions = questions_with_valid_data
            
        except Exception as e:
            print(f&#34;Error parsing/validating questions: {e}&#34;)
            questions = []
        
        return {
            &#34;identifier&#34;: quiz_data.get(&#34;identifier&#34;),
            &#34;name&#34;: quiz_data.get(&#34;name&#34;),
            &#34;questions&#34;: questions,
            &#34;quiz_type&#34;: quiz_data.get(&#34;quiz_type&#34;),
            &#34;is_editing&#34;: quiz_data.get(&#34;is_editing&#34;),
            &#34;original_quiz_id&#34;: quiz_data.get(&#34;original_quiz_id&#34;),
            &#34;last_updated&#34;: quiz_data.get(&#34;last_updated&#34;),
            &#34;media_validation_performed&#34;: True  # Flag to indicate media was checked
        }
    
    except Exception as e:
        print(f&#34;Error retrieving unfinished quiz: {e}&#34;)
        return None</code></pre>
</details>
<div class="desc"><p>Get a specific unfinished quiz by identifier.</p>
<p>Retrieves a complete quiz draft including all questions.
Performs validation on media URLs and question references to ensure
all referenced resources still exist.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifier</code></strong></dt>
<dd>The unique identifier of the quiz draft</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Complete quiz draft with validated questions, or None if not found.
The returned quiz includes:</p>
<ul>
<li>identifier: Unique ID</li>
<li>name: Quiz title</li>
<li>questions: List of question objects</li>
<li>quiz_type: Type of quiz</li>
<li>is_editing: Whether this is an edit of an existing quiz</li>
<li>original_quiz_id: ID of the original quiz being edited</li>
<li>last_updated: Timestamp of last save</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="app.services.unfinished_quiz_service.UnfinishedQuizService.get_unfinished_quizzes"><code class="name flex">
<span>def <span class="ident">get_unfinished_quizzes</span></span>(<span>) â€‘>Â List[Dict[str,Â Any]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_unfinished_quizzes() -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;
    Get all unfinished quizzes for the current device.
    
    Retrieves all saved drafts associated with the current device ID,
    sorted by last update time (newest first).
    
    Returns:
        list: List of quiz draft metadata dictionaries with:

             - identifier: Unique ID for the draft
             - name: Quiz title
             - is_editing: Whether this is an edit of an existing quiz
             - original_quiz_id: ID of the original quiz being edited
             - last_updated: Timestamp of last save
             - question_count: Number of questions in the draft
    &#34;&#34;&#34;
    if not local_db:
        return []
    
    try:
        device_id = get_device_id()
        Quiz = Query()
        
        quizzes = local_db[&#39;unfinished_quizzes&#39;].search(Quiz.device_id == device_id)
        
        # Format quizzes for display
        formatted_quizzes = []
        for q in quizzes:
            formatted_quizzes.append({
                &#34;identifier&#34;: q.get(&#34;identifier&#34;),
                &#34;name&#34;: q.get(&#34;name&#34;),
                &#34;is_editing&#34;: q.get(&#34;is_editing&#34;),
                &#34;original_quiz_id&#34;: q.get(&#34;original_quiz_id&#34;),
                &#34;last_updated&#34;: q.get(&#34;last_updated&#34;),
                &#34;question_count&#34;: q.get(&#34;question_count&#34;, 0)
            })
        
        # Sort by last updated, newest first
        formatted_quizzes.sort(key=lambda x: x.get(&#34;last_updated&#34;, &#34;&#34;), reverse=True)
        
        return formatted_quizzes
    
    except Exception as e:
        print(f&#34;Error retrieving unfinished quizzes: {e}&#34;)
        return []</code></pre>
</details>
<div class="desc"><p>Get all unfinished quizzes for the current device.</p>
<p>Retrieves all saved drafts associated with the current device ID,
sorted by last update time (newest first).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>
<p>List of quiz draft metadata dictionaries with:</p>
<ul>
<li>identifier: Unique ID for the draft</li>
<li>name: Quiz title</li>
<li>is_editing: Whether this is an edit of an existing quiz</li>
<li>original_quiz_id: ID of the original quiz being edited</li>
<li>last_updated: Timestamp of last save</li>
<li>question_count: Number of questions in the draft</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="app.services.unfinished_quiz_service.UnfinishedQuizService.save_unfinished_quiz"><code class="name flex">
<span>def <span class="ident">save_unfinished_quiz</span></span>(<span>quiz_data:Â Dict[str,Â Any],<br>is_editing:Â boolÂ =Â False,<br>quiz_id:Â strÂ |Â NoneÂ =Â None,<br>autosave_id:Â strÂ |Â NoneÂ =Â None) â€‘>Â Tuple[bool,Â str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_unfinished_quiz(quiz_data: Dict[str, Any], is_editing: bool = False, 
                       quiz_id: Optional[str] = None, autosave_id: Optional[str] = None) -&gt; Tuple[bool, str]:
    &#34;&#34;&#34;
    Save or update an unfinished quiz in the local database.
    
    Handles both new quiz drafts and updates to existing drafts.
    Generates a unique identifier for new drafts or uses the provided autosave_id.
    
    Args:
        quiz_data: Dictionary containing the quiz data to save
        is_editing: Whether this is an edit of an existing quiz
        quiz_id: ID of the original quiz being edited (if applicable)
        autosave_id: Existing autosave identifier for updates
        
    Returns:
        tuple: (success_boolean, autosave_identifier)
               
               (False, None) if saving fails
    &#34;&#34;&#34;
    # Don&#39;t save if we&#39;re editing an existing quiz, since it&#39;s not implemented
    if is_editing:
        return False, None
        
    if not local_db:
        print(&#34;Local database not available&#34;)
        return False, None
    
    try:
        device_id = get_device_id()
        
        # Determine the identifier for this autosave
        identifier = None
        
        # If autosave_id was provided, use that - this means we&#39;re updating an existing autosave
        if autosave_id:
            identifier = autosave_id
        else:
            # Always create a unique ID for a new quiz
            identifier = f&#34;new_{int(datetime.now().timestamp())}_{hash(str(quiz_data))}&#34;
        
        # Basic validation
        if not quiz_data or not quiz_data.get(&#39;questions&#39;) or not isinstance(quiz_data.get(&#39;questions&#39;), list):
            print(&#34;Invalid quiz data - missing questions array&#34;)
            return False, None
            
        # Prepare quiz data
        save_data = {
            &#34;identifier&#34;: identifier,
            &#34;name&#34;: quiz_data.get(&#39;name&#39;, &#39;Unnamed Quiz&#39;),
            &#34;questions&#34;: json.dumps(quiz_data.get(&#39;questions&#39;)),  # Serialize questions to string
            &#34;quiz_type&#34;: quiz_data.get(&#39;quiz_type&#39;, &#39;ABCD&#39;),
            &#34;is_editing&#34;: is_editing,
            &#34;original_quiz_id&#34;: quiz_id,
            &#34;device_id&#34;: device_id,
            &#34;last_updated&#34;: datetime.now().isoformat(),
            &#34;question_count&#34;: len(quiz_data.get(&#39;questions&#39;, [])),
            &#34;creation_time&#34;: datetime.now().isoformat() # Track when it was first created
        }
        
        # Check if this quiz already exists by identifier
        Quiz = Query()
        existing = local_db[&#39;unfinished_quizzes&#39;].search(Quiz.identifier == identifier)
        
        if existing:
            # Update existing record
            local_db[&#39;unfinished_quizzes&#39;].update(save_data, Quiz.identifier == identifier)
        else:
            # Create new record
            local_db[&#39;unfinished_quizzes&#39;].insert(save_data)
        
        return True, identifier
    
    except Exception as e:
        print(f&#34;Error saving unfinished quiz: {e}&#34;)
        return False, None</code></pre>
</details>
<div class="desc"><p>Save or update an unfinished quiz in the local database.</p>
<p>Handles both new quiz drafts and updates to existing drafts.
Generates a unique identifier for new drafts or uses the provided autosave_id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>quiz_data</code></strong></dt>
<dd>Dictionary containing the quiz data to save</dd>
<dt><strong><code>is_editing</code></strong></dt>
<dd>Whether this is an edit of an existing quiz</dd>
<dt><strong><code>quiz_id</code></strong></dt>
<dd>ID of the original quiz being edited (if applicable)</dd>
<dt><strong><code>autosave_id</code></strong></dt>
<dd>Existing autosave identifier for updates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<p>(success_boolean, autosave_identifier)</p>
<p>(False, None) if saving fails</p>
</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app.services" href="index.html">app.services</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="app.services.unfinished_quiz_service.UnfinishedQuizService" href="#app.services.unfinished_quiz_service.UnfinishedQuizService">UnfinishedQuizService</a></code></h4>
<ul class="">
<li><code><a title="app.services.unfinished_quiz_service.UnfinishedQuizService.delete_unfinished_quiz" href="#app.services.unfinished_quiz_service.UnfinishedQuizService.delete_unfinished_quiz">delete_unfinished_quiz</a></code></li>
<li><code><a title="app.services.unfinished_quiz_service.UnfinishedQuizService.get_unfinished_quiz" href="#app.services.unfinished_quiz_service.UnfinishedQuizService.get_unfinished_quiz">get_unfinished_quiz</a></code></li>
<li><code><a title="app.services.unfinished_quiz_service.UnfinishedQuizService.get_unfinished_quizzes" href="#app.services.unfinished_quiz_service.UnfinishedQuizService.get_unfinished_quizzes">get_unfinished_quizzes</a></code></li>
<li><code><a title="app.services.unfinished_quiz_service.UnfinishedQuizService.save_unfinished_quiz" href="#app.services.unfinished_quiz_service.UnfinishedQuizService.save_unfinished_quiz">save_unfinished_quiz</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
