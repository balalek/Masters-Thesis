<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>app.services.question_handlers.base_handler API documentation</title>
<meta name="description" content="Base question handler class implementing the strategy pattern
for processing different question types. Provides common functionality
for validation, …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.services.question_handlers.base_handler</code></h1>
</header>
<section id="section-intro">
<p>Base question handler class implementing the strategy pattern
for processing different question types. Provides common functionality
for validation, creation, formatting, and reference management that
specialized question handlers can extend.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="app.services.question_handlers.base_handler.BaseQuestionHandler"><code class="flex name class">
<span>class <span class="ident">BaseQuestionHandler</span></span>
<span>(</span><span>question_type: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseQuestionHandler:
    &#34;&#34;&#34;
    Base class for handling different question types.
    
    This abstract class defines the interface and common functionality
    for all question type handlers. Each specific question type
    (ABCD, True/False, Drawing, etc.) should extend this class and
    implement the type-specific methods.
    
    The handler pattern allows for polymorphic processing of different
    question types throughout the application.
    &#34;&#34;&#34;
    
    def __init__(self, question_type: str):
        &#34;&#34;&#34;
        Initialize a new question handler for a specific type.
        
        Args:
            question_type: The type identifier for questions this handler processes
        &#34;&#34;&#34;
        self.question_type = question_type
    
    def validate(self, question_data: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34;
        Validate the question data based on its type.
        
        Performs basic validation common to all question types.
        Should be overridden by subclasses with additional type-specific validation.
        
        Args:
            question_data: The question data to validate
            
        Returns:
            bool: True if the question data is valid, False otherwise
        &#34;&#34;&#34;
        return &#39;question&#39; in question_data and question_data.get(&#39;type&#39;) == self.question_type
    
    def create_question_dict(self, question_data: Dict[str, Any], quiz_id: ObjectId, 
                            device_id: str, original: Optional[Dict[str, Any]] = None) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Create a standardized question dictionary with common fields.
        
        Processes raw question data into the format required for database storage,
        handling both new questions and updates to existing questions.
        
        Args:
            question_data: Raw question data from the frontend
            quiz_id: MongoDB ObjectId of the parent quiz
            device_id: Device identifier of the creator/editor
            original: The original question document if this is an update
        
        Returns:
            Dict: Processed question dictionary ready for database insertion/update
        &#34;&#34;&#34;
        is_modified = question_data.get(&#34;modified&#34;, False)
        is_existing = original is not None
        
        question_dict = {
            &#34;question&#34;: question_data[&#34;question&#34;],
            &#34;type&#34;: self.question_type,
            &#34;length&#34;: question_data.get(&#34;timeLimit&#34;, question_data.get(&#34;length&#34;, QUIZ_VALIDATION[&#34;TIME_LIMIT_DEFAULT&#34;])),
            &#34;category&#34;: question_data[&#34;category&#34;],
            &#34;part_of&#34;: quiz_id,
            &#34;created_by&#34;: device_id,
            &#34;copy_of&#34;: self._determine_copy_of(question_data, original, is_modified, is_existing),
            &#34;metadata&#34;: QuestionMetadata().to_dict()
        }
        
        # Add type-specific fields by calling the subclass method
        question_dict.update(self.add_type_specific_fields(question_data))
        
        return question_dict
    
    def add_type_specific_fields(self, question_data: Dict[str, Any]) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Add fields specific to this question type.
        
        This is a hook method to be implemented by subclasses to add
        fields that are unique to their specific question type.
        
        Args:
            question_data: The raw question data from the frontend
            
        Returns:
            Dict: Dictionary with type-specific fields to be added to the question
        &#34;&#34;&#34;
        return {}
    
    def format_for_frontend(self, question: Dict[str, Any], quiz_name: str = &#34;Unknown Quiz&#34;) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Format a database question document for frontend display.
        
        Transforms the database representation of a question into a format
        that the frontend can use, including computed and derived fields.
        
        Args:
            question: Database question document
            quiz_name: Name of the parent quiz for display purposes
            
        Returns:
            Dict: Formatted question data ready for frontend consumption
        &#34;&#34;&#34;
        question_data = {
            &#39;_id&#39;: str(question[&#39;_id&#39;]),
            &#39;question&#39;: question[&#39;question&#39;],
            &#39;type&#39;: question[&#39;type&#39;],
            &#39;category&#39;: question.get(&#39;category&#39;, &#39;&#39;),
            &#39;length&#39;: question.get(&#39;length&#39;, QUIZ_VALIDATION[&#34;TIME_LIMIT_DEFAULT&#34;]),
            &#39;timeLimit&#39;: question.get(&#39;length&#39;, QUIZ_VALIDATION[&#34;TIME_LIMIT_DEFAULT&#34;]),
            &#39;quizName&#39;: quiz_name,
            &#39;timesPlayed&#39;: question.get(&#39;metadata&#39;, {}).get(&#39;timesUsed&#39;, 0),
            &#39;copy_of&#39;: str(question[&#39;copy_of&#39;]) if question.get(&#39;copy_of&#39;) else None,
            &#39;isMyQuestion&#39;: False  # This will be set by the caller
        }
        
        return question_data
    
    def _determine_copy_of(self, question_data: Dict[str, Any], original: Optional[Dict[str, Any]], 
                          is_modified: bool, is_existing: bool) -&gt; Optional[ObjectId]:
        &#34;&#34;&#34;
        Determine the &#39;copy_of&#39; reference field value for a question.
        
        Complex logic to establish proper lineage tracking for questions
        that are copied from others or modified from originals.
        
        Args:
            question_data: The question data being processed
            original: Original question document if this is an update
            is_modified: Whether the question has been substantively modified
            is_existing: Whether this is an update to an existing question
            
        Returns:
            ObjectId or None: The ID of the original question this is a copy of, or None
        &#34;&#34;&#34;
        if is_modified:
            return None # It&#39;s a modified question, so it&#39;s not a copy anymore but a new original
        if question_data.get(&#34;copy_of&#34;):
            return ObjectId(question_data[&#34;copy_of&#34;]) # Keep the copy_of reference from the frontend
        if original and original.get(&#34;copy_of&#34;):
            return original[&#34;copy_of&#34;] # This way we track the very first original question
        if not original or (is_existing and str(original[&#34;_id&#34;]) == str(question_data.get(&#34;_id&#34;))):
            return None # This is a new question or this is an update to the original question
        return original[&#34;_id&#34;] # This is a copy of an existing question, which doesn&#39;t have a copy_of reference
    
    @staticmethod
    def handle_copy_references(old_question_id: ObjectId, copies: List[Dict[str, Any]]) -&gt; None:
        &#34;&#34;&#34;
        Handle copy_of references when an original question is changed or removed.
        
        Ensures the integrity of the question lineage by promoting the oldest copy
        to be the new original when the original question is deleted or significantly changed.
        
        Args:
            old_question_id: ID of the original question being removed/changed
            copies: List of question documents that are copies of the original
        &#34;&#34;&#34;
        if copies:
            # Find oldest copy to become new original
            # Use the created_at field if it exists, otherwise use _id as a fallback
            new_original = min(copies, key=lambda x: x.get(&#34;created_at&#34;, x.get(&#34;_id&#34;, datetime.max)))
            new_original_id = new_original[&#34;_id&#34;]
            
            # Update all other copies to point to new original
            db.questions.update_many(
                {
                    &#34;copy_of&#34;: old_question_id,
                    &#34;_id&#34;: {&#34;$ne&#34;: new_original_id}
                },
                {&#34;$set&#34;: {&#34;copy_of&#34;: new_original_id}}
            )
            # Make new original a true original
            db.questions.update_one(
                {&#34;_id&#34;: new_original_id},
                {&#34;$set&#34;: {&#34;copy_of&#34;: None}}
            )</code></pre>
</details>
<div class="desc"><p>Base class for handling different question types.</p>
<p>This abstract class defines the interface and common functionality
for all question type handlers. Each specific question type
(ABCD, True/False, Drawing, etc.) should extend this class and
implement the type-specific methods.</p>
<p>The handler pattern allows for polymorphic processing of different
question types throughout the application.</p>
<p>Initialize a new question handler for a specific type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>question_type</code></strong></dt>
<dd>The type identifier for questions this handler processes</dd>
</dl></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="app.services.question_handlers.abcd_handler.AbcdQuestionHandler" href="abcd_handler.html#app.services.question_handlers.abcd_handler.AbcdQuestionHandler">AbcdQuestionHandler</a></li>
<li><a title="app.services.question_handlers.blind_map_handler.BlindMapQuestionHandler" href="blind_map_handler.html#app.services.question_handlers.blind_map_handler.BlindMapQuestionHandler">BlindMapQuestionHandler</a></li>
<li><a title="app.services.question_handlers.drawing_handler.DrawingQuestionHandler" href="drawing_handler.html#app.services.question_handlers.drawing_handler.DrawingQuestionHandler">DrawingQuestionHandler</a></li>
<li><a title="app.services.question_handlers.guess_a_number_handler.GuessANumberQuestionHandler" href="guess_a_number_handler.html#app.services.question_handlers.guess_a_number_handler.GuessANumberQuestionHandler">GuessANumberQuestionHandler</a></li>
<li><a title="app.services.question_handlers.math_quiz_handler.MathQuizQuestionHandler" href="math_quiz_handler.html#app.services.question_handlers.math_quiz_handler.MathQuizQuestionHandler">MathQuizQuestionHandler</a></li>
<li><a title="app.services.question_handlers.open_answer_handler.OpenAnswerQuestionHandler" href="open_answer_handler.html#app.services.question_handlers.open_answer_handler.OpenAnswerQuestionHandler">OpenAnswerQuestionHandler</a></li>
<li><a title="app.services.question_handlers.true_false_handler.TrueFalseQuestionHandler" href="true_false_handler.html#app.services.question_handlers.true_false_handler.TrueFalseQuestionHandler">TrueFalseQuestionHandler</a></li>
<li><a title="app.services.question_handlers.word_chain_handler.WordChainQuestionHandler" href="word_chain_handler.html#app.services.question_handlers.word_chain_handler.WordChainQuestionHandler">WordChainQuestionHandler</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="app.services.question_handlers.base_handler.BaseQuestionHandler.handle_copy_references"><code class="name flex">
<span>def <span class="ident">handle_copy_references</span></span>(<span>old_question_id: bson.objectid.ObjectId, copies: List[Dict[str, Any]]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def handle_copy_references(old_question_id: ObjectId, copies: List[Dict[str, Any]]) -&gt; None:
    &#34;&#34;&#34;
    Handle copy_of references when an original question is changed or removed.
    
    Ensures the integrity of the question lineage by promoting the oldest copy
    to be the new original when the original question is deleted or significantly changed.
    
    Args:
        old_question_id: ID of the original question being removed/changed
        copies: List of question documents that are copies of the original
    &#34;&#34;&#34;
    if copies:
        # Find oldest copy to become new original
        # Use the created_at field if it exists, otherwise use _id as a fallback
        new_original = min(copies, key=lambda x: x.get(&#34;created_at&#34;, x.get(&#34;_id&#34;, datetime.max)))
        new_original_id = new_original[&#34;_id&#34;]
        
        # Update all other copies to point to new original
        db.questions.update_many(
            {
                &#34;copy_of&#34;: old_question_id,
                &#34;_id&#34;: {&#34;$ne&#34;: new_original_id}
            },
            {&#34;$set&#34;: {&#34;copy_of&#34;: new_original_id}}
        )
        # Make new original a true original
        db.questions.update_one(
            {&#34;_id&#34;: new_original_id},
            {&#34;$set&#34;: {&#34;copy_of&#34;: None}}
        )</code></pre>
</details>
<div class="desc"><p>Handle copy_of references when an original question is changed or removed.</p>
<p>Ensures the integrity of the question lineage by promoting the oldest copy
to be the new original when the original question is deleted or significantly changed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>old_question_id</code></strong></dt>
<dd>ID of the original question being removed/changed</dd>
<dt><strong><code>copies</code></strong></dt>
<dd>List of question documents that are copies of the original</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="app.services.question_handlers.base_handler.BaseQuestionHandler.add_type_specific_fields"><code class="name flex">
<span>def <span class="ident">add_type_specific_fields</span></span>(<span>self, question_data: Dict[str, Any]) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_type_specific_fields(self, question_data: Dict[str, Any]) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Add fields specific to this question type.
    
    This is a hook method to be implemented by subclasses to add
    fields that are unique to their specific question type.
    
    Args:
        question_data: The raw question data from the frontend
        
    Returns:
        Dict: Dictionary with type-specific fields to be added to the question
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
<div class="desc"><p>Add fields specific to this question type.</p>
<p>This is a hook method to be implemented by subclasses to add
fields that are unique to their specific question type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>question_data</code></strong></dt>
<dd>The raw question data from the frontend</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>Dictionary with type-specific fields to be added to the question</dd>
</dl></div>
</dd>
<dt id="app.services.question_handlers.base_handler.BaseQuestionHandler.create_question_dict"><code class="name flex">
<span>def <span class="ident">create_question_dict</span></span>(<span>self,<br>question_data: Dict[str, Any],<br>quiz_id: bson.objectid.ObjectId,<br>device_id: str,<br>original: Dict[str, Any] | None = None) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_question_dict(self, question_data: Dict[str, Any], quiz_id: ObjectId, 
                        device_id: str, original: Optional[Dict[str, Any]] = None) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Create a standardized question dictionary with common fields.
    
    Processes raw question data into the format required for database storage,
    handling both new questions and updates to existing questions.
    
    Args:
        question_data: Raw question data from the frontend
        quiz_id: MongoDB ObjectId of the parent quiz
        device_id: Device identifier of the creator/editor
        original: The original question document if this is an update
    
    Returns:
        Dict: Processed question dictionary ready for database insertion/update
    &#34;&#34;&#34;
    is_modified = question_data.get(&#34;modified&#34;, False)
    is_existing = original is not None
    
    question_dict = {
        &#34;question&#34;: question_data[&#34;question&#34;],
        &#34;type&#34;: self.question_type,
        &#34;length&#34;: question_data.get(&#34;timeLimit&#34;, question_data.get(&#34;length&#34;, QUIZ_VALIDATION[&#34;TIME_LIMIT_DEFAULT&#34;])),
        &#34;category&#34;: question_data[&#34;category&#34;],
        &#34;part_of&#34;: quiz_id,
        &#34;created_by&#34;: device_id,
        &#34;copy_of&#34;: self._determine_copy_of(question_data, original, is_modified, is_existing),
        &#34;metadata&#34;: QuestionMetadata().to_dict()
    }
    
    # Add type-specific fields by calling the subclass method
    question_dict.update(self.add_type_specific_fields(question_data))
    
    return question_dict</code></pre>
</details>
<div class="desc"><p>Create a standardized question dictionary with common fields.</p>
<p>Processes raw question data into the format required for database storage,
handling both new questions and updates to existing questions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>question_data</code></strong></dt>
<dd>Raw question data from the frontend</dd>
<dt><strong><code>quiz_id</code></strong></dt>
<dd>MongoDB ObjectId of the parent quiz</dd>
<dt><strong><code>device_id</code></strong></dt>
<dd>Device identifier of the creator/editor</dd>
<dt><strong><code>original</code></strong></dt>
<dd>The original question document if this is an update</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>Processed question dictionary ready for database insertion/update</dd>
</dl></div>
</dd>
<dt id="app.services.question_handlers.base_handler.BaseQuestionHandler.format_for_frontend"><code class="name flex">
<span>def <span class="ident">format_for_frontend</span></span>(<span>self, question: Dict[str, Any], quiz_name: str = 'Unknown Quiz') ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_for_frontend(self, question: Dict[str, Any], quiz_name: str = &#34;Unknown Quiz&#34;) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Format a database question document for frontend display.
    
    Transforms the database representation of a question into a format
    that the frontend can use, including computed and derived fields.
    
    Args:
        question: Database question document
        quiz_name: Name of the parent quiz for display purposes
        
    Returns:
        Dict: Formatted question data ready for frontend consumption
    &#34;&#34;&#34;
    question_data = {
        &#39;_id&#39;: str(question[&#39;_id&#39;]),
        &#39;question&#39;: question[&#39;question&#39;],
        &#39;type&#39;: question[&#39;type&#39;],
        &#39;category&#39;: question.get(&#39;category&#39;, &#39;&#39;),
        &#39;length&#39;: question.get(&#39;length&#39;, QUIZ_VALIDATION[&#34;TIME_LIMIT_DEFAULT&#34;]),
        &#39;timeLimit&#39;: question.get(&#39;length&#39;, QUIZ_VALIDATION[&#34;TIME_LIMIT_DEFAULT&#34;]),
        &#39;quizName&#39;: quiz_name,
        &#39;timesPlayed&#39;: question.get(&#39;metadata&#39;, {}).get(&#39;timesUsed&#39;, 0),
        &#39;copy_of&#39;: str(question[&#39;copy_of&#39;]) if question.get(&#39;copy_of&#39;) else None,
        &#39;isMyQuestion&#39;: False  # This will be set by the caller
    }
    
    return question_data</code></pre>
</details>
<div class="desc"><p>Format a database question document for frontend display.</p>
<p>Transforms the database representation of a question into a format
that the frontend can use, including computed and derived fields.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>question</code></strong></dt>
<dd>Database question document</dd>
<dt><strong><code>quiz_name</code></strong></dt>
<dd>Name of the parent quiz for display purposes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>Formatted question data ready for frontend consumption</dd>
</dl></div>
</dd>
<dt id="app.services.question_handlers.base_handler.BaseQuestionHandler.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, question_data: Dict[str, Any]) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, question_data: Dict[str, Any]) -&gt; bool:
    &#34;&#34;&#34;
    Validate the question data based on its type.
    
    Performs basic validation common to all question types.
    Should be overridden by subclasses with additional type-specific validation.
    
    Args:
        question_data: The question data to validate
        
    Returns:
        bool: True if the question data is valid, False otherwise
    &#34;&#34;&#34;
    return &#39;question&#39; in question_data and question_data.get(&#39;type&#39;) == self.question_type</code></pre>
</details>
<div class="desc"><p>Validate the question data based on its type.</p>
<p>Performs basic validation common to all question types.
Should be overridden by subclasses with additional type-specific validation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>question_data</code></strong></dt>
<dd>The question data to validate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the question data is valid, False otherwise</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app.services.question_handlers" href="index.html">app.services.question_handlers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="app.services.question_handlers.base_handler.BaseQuestionHandler" href="#app.services.question_handlers.base_handler.BaseQuestionHandler">BaseQuestionHandler</a></code></h4>
<ul class="">
<li><code><a title="app.services.question_handlers.base_handler.BaseQuestionHandler.add_type_specific_fields" href="#app.services.question_handlers.base_handler.BaseQuestionHandler.add_type_specific_fields">add_type_specific_fields</a></code></li>
<li><code><a title="app.services.question_handlers.base_handler.BaseQuestionHandler.create_question_dict" href="#app.services.question_handlers.base_handler.BaseQuestionHandler.create_question_dict">create_question_dict</a></code></li>
<li><code><a title="app.services.question_handlers.base_handler.BaseQuestionHandler.format_for_frontend" href="#app.services.question_handlers.base_handler.BaseQuestionHandler.format_for_frontend">format_for_frontend</a></code></li>
<li><code><a title="app.services.question_handlers.base_handler.BaseQuestionHandler.handle_copy_references" href="#app.services.question_handlers.base_handler.BaseQuestionHandler.handle_copy_references">handle_copy_references</a></code></li>
<li><code><a title="app.services.question_handlers.base_handler.BaseQuestionHandler.validate" href="#app.services.question_handlers.base_handler.BaseQuestionHandler.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
