<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>app.socketio_events.drawing_events API documentation</title>
<meta name="description" content="Socket.IO events for Drawing questions …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.socketio_events.drawing_events</code></h1>
</header>
<section id="section-intro">
<p>Socket.IO events for Drawing questions</p>
<p>This module provides real-time event handling for Drawing questions:</p>
<ul>
<li>Real-time drawing coordination between drawer and guessers</li>
<li>Word selection and announcement to players</li>
<li>Drawing transmission and broadcasting</li>
<li>Answer submission and validation</li>
<li>Points calculation for both drawer and successful guessers</li>
<li>Letter reveal functionality for hints</li>
<li>Team and individual play modes</li>
</ul>
<p>Drawing is an interactive game where one player draws a word and others
try to guess it, with points awarded for both successful drawing and guessing.</p>
<p>Author: Bc. Martin Baláž</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="app.socketio_events.drawing_events.analyze_drawing_answer"><code class="name flex">
<span>def <span class="ident">analyze_drawing_answer</span></span>(<span>answer, correct_answer)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_drawing_answer(answer, correct_answer):
    &#34;&#34;&#34;
    Analyze how close a guess is to the correct drawing word.
    
    Provides contextual feedback based on length difference and text similarity,
    helping players adjust their guesses toward the correct answer.
    
    Args:
        answer (str): The player&#39;s submitted guess
        correct_answer (str): The actual word being drawn
        
    Returns:
        str: Feedback message based on how close the guess is
    &#34;&#34;&#34;
    answer = answer.lower().strip()
    correct_answer = correct_answer.lower().strip()
    
    # If length differs significantly, give length hint
    if len(answer) &lt; len(correct_answer) * 0.7:
        return &#34;Tvoje odpověď je příliš krátká&#34;
    
    if len(answer) &gt; len(correct_answer) * 1.3:
        return &#34;Tvoje odpověď je příliš dlouhá&#34;
    
    # Calculate similarity ratio
    similarity = SequenceMatcher(None, answer, correct_answer).ratio()
    
    if similarity &gt; 0.8:
        return &#34;Už jsi skoro u cíle! Zkontroluj překlepy&#34;
    elif similarity &gt; 0.5:
        return &#34;Blížíš se k správné odpovědi&#34;
    else:
        return &#34;To není správná odpověď&#34;</code></pre>
</details>
<div class="desc"><p>Analyze how close a guess is to the correct drawing word.</p>
<p>Provides contextual feedback based on length difference and text similarity,
helping players adjust their guesses toward the correct answer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>answer</code></strong> :&ensp;<code>str</code></dt>
<dd>The player's submitted guess</dd>
<dt><strong><code>correct_answer</code></strong> :&ensp;<code>str</code></dt>
<dd>The actual word being drawn</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Feedback message based on how close the guess is</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.drawing_events.calculate_drawer_stats"><code class="name flex">
<span>def <span class="ident">calculate_drawer_stats</span></span>(<span>drawer_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_drawer_stats(drawer_name):
    &#34;&#34;&#34;
    Calculate points and statistics for the drawer.
    
    Computes points earned by the drawer based on how many players guessed correctly.
    Handles different scoring calculations for team mode vs individual mode,
    and applies late word selection penalties when applicable.
    
    Args:
        drawer_name (str): Name of the player who was drawing
        
    Returns:
        dict:

            - pointsEarned: Points earned in this drawing round
            - totalPoints: Drawer&#39;s current total score
            - correct_count: Number of players who guessed correctly
            - total_guessers: Total number of potential guessers
            - is_late_selection: Whether word was selected late
    &#34;&#34;&#34;
    # Calculate how many players guessed correctly
    correct_count = game_state.drawing_stats[&#39;correct_count&#39;]
    total_guessers = len(game_state.players) - 1  # Everyone except drawer
    
    # Get the current question data to check for late selection
    current_question_data = game_state.questions[game_state.current_question]
    is_late_selection = current_question_data.get(&#39;is_late_selection&#39;, False)
    
    # Calculate drawer points using the new formula
    drawer_points_earned = 0
    
    if game_state.is_team_mode:
        # For team mode, we still use the original formula since teams are balanced
        for answer in game_state.drawing_stats[&#39;player_answers&#39;]:
            if answer[&#39;is_correct&#39;]:
                points = POINTS_FOR_CORRECT_ANSWER // 2
                # Don&#39;t apply penalty for late selection
                drawer_points_earned += points
    else:
        if total_guessers &gt; 0:
            # Calculate base points per correct guess
            points_per_guess = POINTS_FOR_CORRECT_ANSWER / total_guessers
            
            # Calculate total earned from correct guesses
            drawer_points_earned = int(points_per_guess * correct_count)
            
            # Add bonus if everyone guessed correctly
            if correct_count == total_guessers and total_guessers &gt; 0:
                drawer_points_earned += (POINTS_FOR_CORRECT_ANSWER // 2)
                
            # Apply late selection penalty
            if is_late_selection:
                drawer_points_earned = drawer_points_earned // 2
    
    # Get drawer&#39;s total points
    if game_state.is_team_mode:
        # For team mode, use the team&#39;s total score instead of individual score
        drawer_team = &#39;blue&#39; if drawer_name in game_state.blue_team else &#39;red&#39;
        drawer_total_points = game_state.team_scores[drawer_team]
    elif drawer_name in game_state.players:
        drawer_total_points = game_state.players[drawer_name][&#39;score&#39;]
    else:
        drawer_total_points = 0
    
    # Return drawer stats as a dictionary
    return {
        &#39;pointsEarned&#39;: drawer_points_earned,
        &#39;totalPoints&#39;: drawer_total_points,
        &#39;correct_count&#39;: correct_count,
        &#39;total_guessers&#39;: total_guessers,
        &#39;is_late_selection&#39;: is_late_selection
    }</code></pre>
</details>
<div class="desc"><p>Calculate points and statistics for the drawer.</p>
<p>Computes points earned by the drawer based on how many players guessed correctly.
Handles different scoring calculations for team mode vs individual mode,
and applies late word selection penalties when applicable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>drawer_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the player who was drawing</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dict:</p>
<pre><code>- pointsEarned: Points earned in this drawing round
- totalPoints: Drawer's current total score
- correct_count: Number of players who guessed correctly
- total_guessers: Total number of potential guessers
- is_late_selection: Whether word was selected late
</code></pre></div>
</dd>
<dt id="app.socketio_events.drawing_events.check_drawing_completion"><code class="name flex">
<span>def <span class="ident">check_drawing_completion</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_drawing_completion():
    &#34;&#34;&#34;
    Check if drawing round completion criteria have been met.
    
    In team mode: At least one player from the drawer&#39;s team must answer correctly

    In free-for-all mode: All players except the drawer must answer correctly
    
    If completion criteria are met, awards bonus points to the drawer (in free-for-all)
    and triggers the results display.
    &#34;&#34;&#34;
    # Get the current drawer&#39;s name
    current_question_data = game_state.questions[game_state.current_question]
    drawer_name = current_question_data.get(&#39;player&#39;)
    
    # Calculate total number of potential guessers (excluding the drawer)
    if game_state.is_team_mode:
        required_correct = 1  # At least one player from the drawer&#39;s team must answer correctly
    else:
        required_correct = len(game_state.players) - 1  # All players except drawer
    
    # Count correct answers
    correct_count = game_state.drawing_stats[&#39;correct_count&#39;]
    
    # If all potential guessers have answered correctly, show results and award bonus
    if correct_count &gt;= required_correct:
        # Award bonus to drawer for full completion
        if not game_state.is_team_mode and drawer_name in game_state.players:
            # Calculate bonus (only if everyone guessed correctly)
            bonus_points = POINTS_FOR_CORRECT_ANSWER // 2
            
            # Apply late selection penalty if applicable
            if current_question_data.get(&#39;is_late_selection&#39;, False):
                bonus_points = bonus_points // 2
                
            # Award bonus points to drawer&#39;s actual score
            game_state.players[drawer_name][&#39;score&#39;] += bonus_points
            
        # Show results after awarding bonus
        show_drawing_results()</code></pre>
</details>
<div class="desc"><p>Check if drawing round completion criteria have been met.</p>
<p>In team mode: At least one player from the drawer's team must answer correctly</p>
<p>In free-for-all mode: All players except the drawer must answer correctly</p>
<p>If completion criteria are met, awards bonus points to the drawer (in free-for-all)
and triggers the results display.</p></div>
</dd>
<dt id="app.socketio_events.drawing_events.drawing_update"><code class="name flex">
<span>def <span class="ident">drawing_update</span></span>(<span>data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@socketio.on(&#39;drawing_update&#39;)
def drawing_update(data):
    &#34;&#34;&#34;
    Broadcast drawing updates from the drawer to all clients (but only main screen listens).
    
    Receives drawing data from the current drawer and broadcasts it to all
    clients to display the drawing in real-time. Validates that updates
    only come from the designated drawer for the current question.
    
    Args:
        data (dict):

            - player_name: Name of the player sending drawing data
            - drawingData: Drawing data to broadcast (lines, colors, etc.)
            - action: Type of drawing action (&#39;draw&#39;, &#39;clear&#39;, etc.)
    
    Emits:
        - &#39;drawing_update_broadcast&#39;: Drawing data to all clients
    &#34;&#34;&#34;
    # Get the current drawer
    if game_state.current_question is None:
        print(&#34;drawing_update: No active question&#34;)
        return
    
    current_question_data = game_state.questions[game_state.current_question]
    drawer_name = current_question_data.get(&#39;player&#39;)
    player_name = data.get(&#39;player_name&#39;)
    
    if player_name != drawer_name:
        # Prevent non-drawers from sending drawing updates
        print(f&#34;drawing_update: Player {player_name} is not the drawer&#34;)
        return
    
    drawing_data = data.get(&#39;drawingData&#39;)
    
    # Broadcast drawing update to all clients
    socketio.emit(&#39;drawing_update_broadcast&#39;, {
        &#39;drawingData&#39;: drawing_data,
        &#39;action&#39;: data.get(&#39;action&#39;, &#39;draw&#39;),
        &#39;drawer&#39;: drawer_name
    })</code></pre>
</details>
<div class="desc"><p>Broadcast drawing updates from the drawer to all clients (but only main screen listens).</p>
<p>Receives drawing data from the current drawer and broadcasts it to all
clients to display the drawing in real-time. Validates that updates
only come from the designated drawer for the current question.</p>
<h2 id="args">Args</h2>
<p>data (dict):</p>
<pre><code>- player_name: Name of the player sending drawing data
- drawingData: Drawing data to broadcast (lines, colors, etc.)
- action: Type of drawing action ('draw', 'clear', etc.)
</code></pre>
<h2 id="emits">Emits</h2>
<ul>
<li>'drawing_update_broadcast': Drawing data to all clients</li>
</ul></div>
</dd>
<dt id="app.socketio_events.drawing_events.get_current_drawing_word"><code class="name flex">
<span>def <span class="ident">get_current_drawing_word</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@socketio.on(&#39;get_current_drawing_word&#39;)
def get_current_drawing_word():
    &#34;&#34;&#34;
    Return the currently selected drawing word in masked format.
    
    Responds to client requests for the current drawing word,
    returning a masked version with only revealed letters shown.
    Used when players join mid-game or need to refresh their display.
    
    Emits:
        - &#39;drawing_word_response&#39;: Contains the masked word and availability flag
    &#34;&#34;&#34;
    if game_state.current_question is None:
        return
    
    current_question_data = game_state.questions[game_state.current_question]
    
    # Only for drawing questions
    if current_question_data.get(&#39;type&#39;) != &#39;DRAWING&#39;:
        return
    
    # Get the selected word
    selected_word = current_question_data.get(&#39;selected_word&#39;)
    if not selected_word:
        return  # No word selected yet
    
    # Create a masked version with already revealed letters
    mask = [&#39;_&#39; if i not in game_state.revealed_positions and char != &#39; &#39; else char 
            for i, char in enumerate(selected_word)]
    
    # Send the masked version of the word
    data = {
        &#34;word&#34;: &#39;&#39;.join(mask),
        &#34;mask_available&#34;: True
    }
    
    # Emit directly to the requesting client
    emit(&#39;drawing_word_response&#39;, data)</code></pre>
</details>
<div class="desc"><p>Return the currently selected drawing word in masked format.</p>
<p>Responds to client requests for the current drawing word,
returning a masked version with only revealed letters shown.
Used when players join mid-game or need to refresh their display.</p>
<h2 id="emits">Emits</h2>
<ul>
<li>'drawing_word_response': Contains the masked word and availability flag</li>
</ul></div>
</dd>
<dt id="app.socketio_events.drawing_events.handle_drawing_time_up"><code class="name flex">
<span>def <span class="ident">handle_drawing_time_up</span></span>(<span>scores)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_drawing_time_up(scores):
    &#34;&#34;&#34;
    Handle time expiration for drawing questions.
    
    Processes the end of a drawing round when time runs out,
    regardless of how many players have guessed correctly.
    Calculates final drawer statistics and broadcasts results.
    
    Args:
        scores: Current game scores for inclusion in results
    
    Emits:
        - Event via emit_all_answers_received with drawing results
    &#34;&#34;&#34;
    current_question = game_state.questions[game_state.current_question]
    drawer_name = current_question.get(&#39;player&#39;, &#39;&#39;)
    correct_answer = current_question.get(&#39;selected_word&#39;, &#39;&#39;)
    
    # Get drawer stats using the helper function
    drawer_stats = calculate_drawer_stats(drawer_name) if drawer_name else None
    
    # Sort player answers by dissimilarity for &#34;most interesting attempts&#34;
    sorted_player_answers = sort_player_answers_by_dissimilarity(
        game_state.drawing_stats[&#39;player_answers&#39;],
        correct_answer
    )
    
    # Send standard results to everyone with drawer stats included
    emit_all_answers_received(
        scores=scores,
        correct_answer=correct_answer,
        additional_data={
            &#34;player_answers&#34;: sorted_player_answers,
            &#34;drawer&#34;: drawer_name,
            &#34;drawer_stats&#34;: drawer_stats
        }
    )</code></pre>
</details>
<div class="desc"><p>Handle time expiration for drawing questions.</p>
<p>Processes the end of a drawing round when time runs out,
regardless of how many players have guessed correctly.
Calculates final drawer statistics and broadcasts results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scores</code></strong></dt>
<dd>Current game scores for inclusion in results</dd>
</dl>
<h2 id="emits">Emits</h2>
<ul>
<li>Event via emit_all_answers_received with drawing results</li>
</ul></div>
</dd>
<dt id="app.socketio_events.drawing_events.reveal_drawing_letter"><code class="name flex">
<span>def <span class="ident">reveal_drawing_letter</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@socketio.on(&#39;reveal_drawing_letter&#39;)
def reveal_drawing_letter():
    &#34;&#34;&#34;
    Reveal a random letter in the drawing answer as a hint.
    
    Randomly reveals one previously hidden letter in the answer,
    up to a maximum of 50% of the total letters. Spaces are always
    shown and not counted toward the reveal limit.
    
    Emits:
        - &#39;drawing_letter_revealed&#39;: Updated mask with newly revealed letter
    &#34;&#34;&#34;
    if game_state.current_question is None:
        return
    
    current_question_data = game_state.questions[game_state.current_question]
    correct_answer = current_question_data.get(&#39;selected_word&#39;, &#39;&#39;)

    # If no word is selected yet, do nothing
    if not correct_answer:
        return

    # Count actual letters (excluding spaces)
    actual_letters = sum(1 for char in correct_answer if char != &#39; &#39;)
    
    # Calculate maximum number of letters to reveal (50% rounded down)
    max_reveals = actual_letters // 2
    
    # Check if we&#39;ve already reached the maximum number of reveals
    if len(game_state.revealed_positions) &gt;= max_reveals:
        return
    
    # Find valid positions (not spaces, not already revealed)
    valid_positions = [i for i in range(len(correct_answer)) 
                      if correct_answer[i] != &#39; &#39; and i not in game_state.revealed_positions]
    
    # If no valid positions, do nothing
    if not valid_positions:
        return
    
    # Choose a random position
    position = random.choice(valid_positions)
    game_state.revealed_positions.add(position)
    
    # Create mask with revealed letters
    mask = [&#39;_&#39; if i not in game_state.revealed_positions and char != &#39; &#39; else char 
            for i, char in enumerate(correct_answer)]
    
    # Send the updated mask
    socketio.emit(&#39;drawing_letter_revealed&#39;, {
        &#39;mask&#39;: &#39;&#39;.join(mask),
        &#39;position&#39;: position
    })</code></pre>
</details>
<div class="desc"><p>Reveal a random letter in the drawing answer as a hint.</p>
<p>Randomly reveals one previously hidden letter in the answer,
up to a maximum of 50% of the total letters. Spaces are always
shown and not counted toward the reveal limit.</p>
<h2 id="emits">Emits</h2>
<ul>
<li>'drawing_letter_revealed': Updated mask with newly revealed letter</li>
</ul></div>
</dd>
<dt id="app.socketio_events.drawing_events.select_drawing_word"><code class="name flex">
<span>def <span class="ident">select_drawing_word</span></span>(<span>data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@socketio.on(&#39;select_drawing_word&#39;)
def select_drawing_word(data):
    &#34;&#34;&#34;
    Handle word selection by the drawer for the current drawing round.
    
    Validates the selection, updates the game state with the chosen word,
    and notifies players - showing the full word to the drawer and a
    masked version to guessers (main screen).
    
    Args:
        data (dict):
        
            - player_name: Name of the player selecting the word
            - selected_word: The word chosen to be drawn
            - is_late_selection: Whether selection was made after time started
    
    Emits:
        - &#39;error&#39;: If selection is invalid
        - &#39;word_selected&#39;: Word info to drawer (full word) and guessers (masked)
    &#34;&#34;&#34;
    player_name = data.get(&#39;player_name&#39;)
    selected_word = data.get(&#39;selected_word&#39;)
    is_late_selection = data.get(&#39;is_late_selection&#39;, False)
    
    if not all([player_name, selected_word]):
        emit(&#39;error&#39;, {&#34;error&#34;: &#34;Missing required data&#34;})
        return
    
    # Use the server&#39;s current question index
    question_index = game_state.current_question
    
    if question_index is None:
        emit(&#39;error&#39;, {&#34;error&#34;: &#34;No active question&#34;})
        return
    
    question = game_state.questions[question_index]
    
    # Verify this is a drawing question for this player
    if question.get(&#34;type&#34;) != &#34;DRAWING&#34; or question.get(&#34;player&#34;) != player_name:
        emit(&#39;error&#39;, {&#34;error&#34;: &#34;Not your drawing question&#34;})
        return
    
    # Verify the selected word is one of the options
    if selected_word not in question.get(&#34;words&#34;, []):
        emit(&#39;error&#39;, {&#34;error&#34;: &#34;Invalid word selected&#34;})
        return
    
    # Set the selected word
    game_state.questions[question_index][&#34;selected_word&#34;] = selected_word
    
    # Store late selection flag to apply penalty later
    game_state.questions[question_index][&#34;is_late_selection&#34;] = is_late_selection
    
    # Reset drawing-specific game state if this is the active question
    if game_state.current_question == question_index:
        game_state.correct_players = set()
        game_state.revealed_positions = set()
        game_state.drawing_stats = {
            &#39;correct_count&#39;: 0,
            &#39;player_answers&#39;: []
        }
    
    # Notify clients that the word has been selected
    # For the drawer, send the full word
    emit(&#39;word_selected&#39;, {
        &#34;word&#34;: selected_word,
        &#34;question_index&#34;: question_index,
        &#34;is_drawer&#34;: True
    }, room=player_name)
    
    # For others, send masked version with underscores
    mask = [&#39;_&#39; if char != &#39; &#39; else &#39; &#39; for char in selected_word]
    socketio.emit(&#39;word_selected&#39;, {
        &#34;word&#34;: &#39;&#39;.join(mask),
        &#34;question_index&#34;: question_index,
        &#34;is_drawer&#34;: False
    }, include_self=False)</code></pre>
</details>
<div class="desc"><p>Handle word selection by the drawer for the current drawing round.</p>
<p>Validates the selection, updates the game state with the chosen word,
and notifies players - showing the full word to the drawer and a
masked version to guessers (main screen).</p>
<h2 id="args">Args</h2>
<p>data (dict):</p>
<pre><code>- player_name: Name of the player selecting the word
- selected_word: The word chosen to be drawn
- is_late_selection: Whether selection was made after time started
</code></pre>
<h2 id="emits">Emits</h2>
<ul>
<li>'error': If selection is invalid</li>
<li>'word_selected': Word info to drawer (full word) and guessers (masked)</li>
</ul></div>
</dd>
<dt id="app.socketio_events.drawing_events.show_drawing_results"><code class="name flex">
<span>def <span class="ident">show_drawing_results</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_drawing_results():
    &#34;&#34;&#34;
    Show results for the drawing round to all players.
    
    Gathers the current scores, correct answer, player answers, and drawer
    statistics, then broadcasts results to all players.
    
    Emits:
        - Event via emit_all_answers_received with drawing results
    &#34;&#34;&#34;
    current_question_data = game_state.questions[game_state.current_question]
    scores = get_scores_data()
    drawer_name = current_question_data.get(&#39;player&#39;, &#39;&#39;)
    correct_answer = current_question_data.get(&#39;selected_word&#39;, &#39;&#39;)
    
    # Get drawer stats using the helper function
    drawer_stats = calculate_drawer_stats(drawer_name) if drawer_name else None
    
    # Sort player answers by dissimilarity for &#34;most interesting attempts&#34;
    sorted_player_answers = sort_player_answers_by_dissimilarity(
        game_state.drawing_stats[&#39;player_answers&#39;],
        correct_answer
    )
    
    # Send standard results to everyone with drawer stats included
    emit_all_answers_received(
        scores=scores,
        correct_answer=correct_answer,
        additional_data={
            &#34;player_answers&#34;: sorted_player_answers,
            &#34;drawer&#34;: drawer_name,
            &#34;drawer_stats&#34;: drawer_stats
        }
    )</code></pre>
</details>
<div class="desc"><p>Show results for the drawing round to all players.</p>
<p>Gathers the current scores, correct answer, player answers, and drawer
statistics, then broadcasts results to all players.</p>
<h2 id="emits">Emits</h2>
<ul>
<li>Event via emit_all_answers_received with drawing results</li>
</ul></div>
</dd>
<dt id="app.socketio_events.drawing_events.sort_player_answers_by_dissimilarity"><code class="name flex">
<span>def <span class="ident">sort_player_answers_by_dissimilarity</span></span>(<span>player_answers, correct_answer)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_player_answers_by_dissimilarity(player_answers, correct_answer):
    &#34;&#34;&#34;
    Sort player answers by their dissimilarity to the correct answer.
    
    This puts the least similar (most interesting) answers first.
    Frontend will then use the top 3 answers for the &#34;most interesting attempts&#34; section.
    
    Args:
        player_answers: List of player answer objects
        correct_answer: The correct answer to compare against
        
    Returns:
        list: Sorted list with correct answers first, then sorted incorrect answers
    &#34;&#34;&#34;
    # Create a copy of the answers list to avoid modifying the original
    player_answers = list(player_answers)
    
    # Separate correct and incorrect answers
    correct_answers = [answer for answer in player_answers if answer[&#39;is_correct&#39;]]
    incorrect_answers = [answer for answer in player_answers if not answer[&#39;is_correct&#39;]]
    
    # Calculate similarity for each incorrect answer
    for answer in incorrect_answers:
        answer_text = answer[&#39;answer&#39;].lower().strip()
        correct_text = correct_answer.lower().strip()
        similarity = SequenceMatcher(None, answer_text, correct_text).ratio()
        answer[&#39;similarity&#39;] = similarity
    
    # Sort incorrect answers by similarity (lowest first)
    sorted_incorrect = sorted(incorrect_answers, key=lambda x: x[&#39;similarity&#39;])
    
    # Recombine the answers with correct answers first, then sorted incorrect answers
    return correct_answers + sorted_incorrect</code></pre>
</details>
<div class="desc"><p>Sort player answers by their dissimilarity to the correct answer.</p>
<p>This puts the least similar (most interesting) answers first.
Frontend will then use the top 3 answers for the "most interesting attempts" section.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player_answers</code></strong></dt>
<dd>List of player answer objects</dd>
<dt><strong><code>correct_answer</code></strong></dt>
<dd>The correct answer to compare against</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Sorted list with correct answers first, then sorted incorrect answers</dd>
</dl></div>
</dd>
<dt id="app.socketio_events.drawing_events.submit_drawing_answer"><code class="name flex">
<span>def <span class="ident">submit_drawing_answer</span></span>(<span>data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@socketio.on(&#39;submit_drawing_answer&#39;)
def submit_drawing_answer(data):
    &#34;&#34;&#34;
    Handle submission of a guess for the drawn word.
    
    Validates the submitted answer against the word being drawn, awards points 
    for correct answers based on speed, and manages team vs individual scoring.
    Provides feedback for incorrect guesses based on similarity.
    
    Args:
        data (dict):

            - player_name: Name of the player submitting the guess
            - answer: The word guess submitted
            - answer_time: Timestamp when answer was submitted
            
    Emits:
        - &#39;error&#39;: If game is not started
        - &#39;drawing_answer_feedback&#39;: Feedback for invalid or incorrect answers
        - &#39;answer_correctness&#39;: Result notification with points for correct answers
        - &#39;drawing_answer_submitted&#39;: Updates for the main screen on player progress
    &#34;&#34;&#34;
    player_name = data[&#39;player_name&#39;]
    answer = data[&#39;answer&#39;].strip()
    answer_time = data[&#39;answer_time&#39;]
    current_question = game_state.current_question
    
    if current_question is None:
        emit(&#39;error&#39;, {&#34;error&#34;: &#34;Game not started&#34;})
        return
    
    # Skip processing if player already answered correctly
    if player_name in game_state.correct_players:
        emit(&#39;drawing_answer_feedback&#39;, {&#34;message&#34;: &#34;Už jsi odpověděl/a správně&#34;}, room=player_name)
        return
    
    # Skip processing if player is the drawer for this question
    current_question_data = game_state.questions[current_question]
    if current_question_data.get(&#39;player&#39;) == player_name:
        emit(&#39;drawing_answer_feedback&#39;, {&#34;message&#34;: &#34;Nemůžeš hádat svůj vlastní obrázek&#34;}, room=player_name)
        return
    
    # In team mode, verify that the player is on the same team as the drawer
    if game_state.is_team_mode:
        drawer_name = current_question_data.get(&#39;player&#39;)
        drawer_team = &#39;blue&#39; if drawer_name in game_state.blue_team else &#39;red&#39;
        player_team = &#39;blue&#39; if player_name in game_state.blue_team else &#39;red&#39;
        
        if player_team != drawer_team:
            emit(&#39;drawing_answer_feedback&#39;, {&#34;message&#34;: &#34;Pouze hráči ze stejného týmu mohou hádat&#34;}, room=player_name)
            return
    
    # Get the word that was selected by the drawer
    selected_word = current_question_data.get(&#39;selected_word&#39;)
    if selected_word is None:
        emit(&#39;drawing_answer_feedback&#39;, {&#34;message&#34;: &#34;Kreslící hráč ještě nevybral slovo&#34;}, room=player_name)
        return
        
    correct_answer = selected_word.strip()
    
    if not correct_answer:
        emit(&#39;drawing_answer_feedback&#39;, {&#34;message&#34;: &#34;Kreslící hráč ještě nevybral slovo&#34;}, room=player_name)
        return
    
    # Normalize both answers for comparison
    normalized_answer = answer.lower()
    normalized_correct = correct_answer.lower()
    
    # Check if answer is correct
    is_correct = normalized_answer == normalized_correct
    
    # If answer is correct
    if is_correct:
        # Calculate speed points
        question_start_time = game_state.question_start_time
        question_length = current_question_data[&#39;length&#39;] * 1000
        time_taken = answer_time - question_start_time
        speed_points = max(0, 100 - int((time_taken / question_length) * 100))
        total_points_earned = POINTS_FOR_CORRECT_ANSWER + speed_points
        
        # Add player to correct players set
        game_state.correct_players.add(player_name)
        
        # Handle scoring based on game mode
        if game_state.is_team_mode:
            team = &#39;blue&#39; if player_name in game_state.blue_team else &#39;red&#39;
            drawer_team = &#39;blue&#39; if current_question_data.get(&#39;player&#39;) in game_state.blue_team else &#39;red&#39;
            
            # Only award points if the guesser is on the same team as the drawer
            if team == drawer_team:
                game_state.team_scores[team] += total_points_earned
                
                # Notify all team members with the correct answer screen
                team_players = game_state.blue_team if team == &#39;blue&#39; else game_state.red_team
                for team_player in team_players:
                    emit(&#39;answer_correctness&#39;, {
                        &#34;correct&#34;: True,
                        &#34;points_earned&#34;: total_points_earned,
                        &#34;total_points&#34;: game_state.team_scores[team],
                        &#34;is_team_score&#34;: True
                    }, room=team_player)
            else:
                # Player is not on the drawer&#39;s team, so no points
                emit(&#39;drawing_answer_feedback&#39;, {
                    &#34;message&#34;: &#34;Správně! Ale body dostává pouze tým kreslícího hráče.&#34;
                }, room=player_name)
        else:
            # Individual mode - award points to the guesser
            game_state.players[player_name][&#39;score&#39;] += total_points_earned
            
            # Also award points to the drawer based on how many players guessed correctly
            drawer_name = current_question_data.get(&#39;player&#39;)
            if drawer_name and drawer_name in game_state.players:
                # Calculate number of potential guessers (everyone except drawer)
                total_guessers = len(game_state.players) - 1
                
                # Calculate points per correct guess
                points_per_guess = POINTS_FOR_CORRECT_ANSWER / total_guessers if total_guessers &gt; 0 else 0
                
                # Apply late selection penalty if applicable
                if current_question_data.get(&#39;is_late_selection&#39;, False):
                    points_per_guess = points_per_guess // 2
                
                # Award points to drawer
                game_state.players[drawer_name][&#39;score&#39;] += int(points_per_guess)
            
            # Notify guesser of points earned
            emit(&#39;answer_correctness&#39;, {
                &#34;correct&#34;: True,
                &#34;points_earned&#34;: total_points_earned,
                &#34;total_points&#34;: game_state.players[player_name][&#39;score&#39;],
                &#34;is_team_score&#34;: False
            }, room=player_name)
        
        # Update tracking for correct answers
        game_state.drawing_stats[&#39;correct_count&#39;] += 1
        game_state.drawing_stats[&#39;player_answers&#39;].append({
            &#39;player_name&#39;: player_name,
            &#39;answer&#39;: answer,
            &#39;is_correct&#39;: True,
            &#39;player_color&#39;: game_state.players[player_name][&#39;color&#39;]
        })
        
        # Broadcast to update main screen
        socketio.emit(&#39;drawing_answer_submitted&#39;, {
            &#39;player_count&#39;: len(game_state.players) - 1,  # Exclude the drawer
            &#39;correct_count&#39;: game_state.drawing_stats[&#39;correct_count&#39;],
            &#39;player_name&#39;: player_name,
            &#39;player_color&#39;: game_state.players[player_name][&#39;color&#39;]
        })
        
        # Check if everyone except the drawer has answered correctly
        check_drawing_completion()
    else:
        # Wrong answer - provide feedback
        feedback = analyze_drawing_answer(answer, correct_answer)
        
        # Log the attempt
        game_state.drawing_stats[&#39;player_answers&#39;].append({
            &#39;player_name&#39;: player_name,
            &#39;answer&#39;: answer,
            &#39;is_correct&#39;: False,
            &#39;player_color&#39;: game_state.players[player_name][&#39;color&#39;]
        })
        
        # Broadcast feedback to the player
        emit(&#39;drawing_answer_feedback&#39;, {&#34;message&#34;: feedback}, room=player_name)</code></pre>
</details>
<div class="desc"><p>Handle submission of a guess for the drawn word.</p>
<p>Validates the submitted answer against the word being drawn, awards points
for correct answers based on speed, and manages team vs individual scoring.
Provides feedback for incorrect guesses based on similarity.</p>
<h2 id="args">Args</h2>
<p>data (dict):</p>
<pre><code>- player_name: Name of the player submitting the guess
- answer: The word guess submitted
- answer_time: Timestamp when answer was submitted
</code></pre>
<h2 id="emits">Emits</h2>
<ul>
<li>'error': If game is not started</li>
<li>'drawing_answer_feedback': Feedback for invalid or incorrect answers</li>
<li>'answer_correctness': Result notification with points for correct answers</li>
<li>'drawing_answer_submitted': Updates for the main screen on player progress</li>
</ul></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app.socketio_events" href="index.html">app.socketio_events</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="app.socketio_events.drawing_events.analyze_drawing_answer" href="#app.socketio_events.drawing_events.analyze_drawing_answer">analyze_drawing_answer</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.calculate_drawer_stats" href="#app.socketio_events.drawing_events.calculate_drawer_stats">calculate_drawer_stats</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.check_drawing_completion" href="#app.socketio_events.drawing_events.check_drawing_completion">check_drawing_completion</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.drawing_update" href="#app.socketio_events.drawing_events.drawing_update">drawing_update</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.get_current_drawing_word" href="#app.socketio_events.drawing_events.get_current_drawing_word">get_current_drawing_word</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.handle_drawing_time_up" href="#app.socketio_events.drawing_events.handle_drawing_time_up">handle_drawing_time_up</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.reveal_drawing_letter" href="#app.socketio_events.drawing_events.reveal_drawing_letter">reveal_drawing_letter</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.select_drawing_word" href="#app.socketio_events.drawing_events.select_drawing_word">select_drawing_word</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.show_drawing_results" href="#app.socketio_events.drawing_events.show_drawing_results">show_drawing_results</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.sort_player_answers_by_dissimilarity" href="#app.socketio_events.drawing_events.sort_player_answers_by_dissimilarity">sort_player_answers_by_dissimilarity</a></code></li>
<li><code><a title="app.socketio_events.drawing_events.submit_drawing_answer" href="#app.socketio_events.drawing_events.submit_drawing_answer">submit_drawing_answer</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
